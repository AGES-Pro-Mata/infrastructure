name: Deploy Infrastructure + Configure (Full Stack)

on:
  push:
    branches: [main]
    paths:
      - 'iac/aws/**'
      - 'cac/**'
      - 'docker-compose.yml'
      - 'docker/**'
      - '.github/workflows/deploy-infra-full.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy      # Terraform + Ansible
          - infra-only  # Only Terraform
          - config-only # Only Ansible (requires existing infra)
          - destroy     # Destroy infrastructure

env:
  AWS_REGION: sa-east-1
  TF_VERSION: 1.10.0
  ANSIBLE_VERSION: 2.15

jobs:
  # ============================================================================
  # TERRAFORM - Provision Infrastructure
  # ============================================================================
  terraform:
    name: Provision Infrastructure
    runs-on: ubuntu-24.04
    if: github.event.inputs.action != 'config-only'
    outputs:
      ec2_ip: ${{ steps.outputs.outputs.ec2_ip }}
      ssh_key: ${{ steps.outputs.outputs.ssh_key }}
    defaults:
      run:
        working-directory: iac/aws

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform Backend
        run: |
          if ! aws s3api head-bucket --bucket promata-terraform-state 2>/dev/null; then
            echo "üì¶ Creating S3 bucket..."
            aws s3api create-bucket --bucket promata-terraform-state --region ${{ env.AWS_REGION }} \
              --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }} || true
            aws s3api put-bucket-versioning --bucket promata-terraform-state \
              --versioning-configuration Status=Enabled || true
          fi
          if ! aws dynamodb describe-table --table-name promata-terraform-locks 2>/dev/null; then
            echo "üîë Creating DynamoDB table..."
            aws dynamodb create-table --table-name promata-terraform-locks \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST || true
            aws dynamodb wait table-exists --table-name promata-terraform-locks || true
          fi

      - name: Terraform Init
        run: terraform init

      - name: Import Existing Resources
        if: github.event.inputs.action != 'destroy'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          chmod +x ../../scripts/terraform/import-all-existing-resources.sh
          ../../scripts/terraform/import-all-existing-resources.sh --auto || true

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: |
          terraform destroy -auto-approve \
            -var="domain_name=${{ vars.DOMAIN_NAME }}" \
            -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}"

      - name: Terraform Apply
        if: github.event.inputs.action != 'destroy'
        run: |
          terraform apply -auto-approve \
            -var="domain_name=${{ vars.DOMAIN_NAME }}" \
            -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}"

      - name: Extract Outputs
        if: github.event.inputs.action != 'destroy'
        id: outputs
        run: |
          echo "ec2_ip=$(terraform output -raw manager_public_ip)" >> $GITHUB_OUTPUT
          # Store SSH key in a file for artifact
          terraform output -raw ssh_private_key > /tmp/ssh_key.pem
          chmod 600 /tmp/ssh_key.pem
          # Base64 encode for passing to next job
          echo "ssh_key=$(terraform output -raw ssh_private_key | base64 -w 0)" >> $GITHUB_OUTPUT

      - name: Upload SSH Key as Artifact
        if: github.event.inputs.action != 'destroy'
        uses: actions/upload-artifact@v4
        with:
          name: ssh-key
          path: /tmp/ssh_key.pem
          retention-days: 1

  # ============================================================================
  # ANSIBLE - Configure Server & Deploy Stack
  # ============================================================================
  ansible:
    name: Configure & Deploy Stack
    runs-on: ubuntu-24.04
    needs: terraform
    if: |
      always() && 
      (needs.terraform.result == 'success' || github.event.inputs.action == 'config-only') &&
      github.event.inputs.action != 'destroy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Ansible
        run: |
          pip install ansible boto3 botocore

      - name: Get EC2 IP
        id: ec2
        run: |
          if [ "${{ github.event.inputs.action }}" == "config-only" ]; then
            # For config-only, use secret or fetch from AWS
            EC2_IP="${{ secrets.EC2_HOST }}"
            if [ -z "$EC2_IP" ]; then
              pip install awscli
              EC2_IP=$(aws ec2 describe-instances \
                --filters "Name=tag:Name,Values=promata-prod-manager" "Name=instance-state-name,Values=running" \
                --query "Reservations[0].Instances[0].PublicIpAddress" \
                --output text --region ${{ env.AWS_REGION }})
            fi
          else
            EC2_IP="${{ needs.terraform.outputs.ec2_ip }}"
          fi
          echo "ip=$EC2_IP" >> $GITHUB_OUTPUT
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Download SSH Key (from Terraform)
        if: github.event.inputs.action != 'config-only'
        uses: actions/download-artifact@v4
        with:
          name: ssh-key
          path: /tmp/

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          if [ "${{ github.event.inputs.action }}" == "config-only" ]; then
            echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/promata.pem
          else
            cp /tmp/ssh_key.pem ~/.ssh/promata.pem
          fi
          chmod 600 ~/.ssh/promata.pem
          
          # Add host to known_hosts
          ssh-keyscan -H ${{ steps.ec2.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Wait for EC2 to be ready
        run: |
          echo "‚è≥ Waiting for EC2 to be SSH-ready..."
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i ~/.ssh/promata.pem ubuntu@${{ steps.ec2.outputs.ip }} "echo 'SSH OK'" 2>/dev/null; then
              echo "‚úÖ EC2 is ready!"
              break
            fi
            echo "Attempt $i/30 - waiting..."
            sleep 10
          done

      - name: Create Ansible Inventory
        run: |
          mkdir -p cac/inventory/prod/group_vars
          
          cat > cac/inventory/prod/hosts.yml << EOF
          all:
            children:
              managers:
                hosts:
                  promata-prod:
                    ansible_host: ${{ steps.ec2.outputs.ip }}
                    ansible_user: ubuntu
                    ansible_ssh_private_key_file: ~/.ssh/promata.pem
                    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
          EOF

      - name: Create Ansible Variables
        run: |
          cat > cac/inventory/prod/group_vars/all.yml << EOF
          # Project Configuration
          project_name: promata
          environment: prod
          domain_name: ${{ vars.DOMAIN_NAME }}
          
          # Docker Configuration  
          docker_compose_version: v2.31.0
          
          # Application Images
          backend_image: norohim/pro-mata-backend:latest
          
          # Stack Environment Variables
          stack_environment:
            DOMAIN_NAME: "${{ vars.DOMAIN_NAME }}"
            POSTGRES_DB: promata
            POSTGRES_USER: promata
            POSTGRES_PASSWORD: "${{ secrets.POSTGRES_PASSWORD }}"
            JWT_SECRET: "${{ secrets.JWT_SECRET }}"
            APP_SECRET: "${{ secrets.APP_SECRET }}"
            ACME_EMAIL: "admin@${{ vars.DOMAIN_NAME }}"
            TRAEFIK_LOG_LEVEL: INFO
          EOF

      - name: Run Ansible Playbook
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
          ANSIBLE_STDOUT_CALLBACK: yaml
          DOMAIN_NAME: ${{ vars.DOMAIN_NAME }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          APP_SECRET: ${{ secrets.APP_SECRET }}
          AWS_REGION: ${{ env.AWS_REGION }}
          S3_BUCKET_NAME: ${{ vars.S3_BUCKET_NAME || 'promata-prod-static-assets' }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          cd cac
          ansible-playbook \
            -i inventory/prod/hosts.yml \
            playbooks/deploy-prod-simple.yml \
            -v

      - name: Verify Deployment
        run: |
          echo "üîç Verifying deployment..."
          sleep 30  # Wait for containers to start
          
          # Check via SSH
          ssh -i ~/.ssh/promata.pem ubuntu@${{ steps.ec2.outputs.ip }} << 'EOF'
            echo "=== Docker Containers ==="
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            echo "=== Docker Compose Services ==="
            cd /opt/promata && docker-compose ps 2>/dev/null || true
          EOF

      - name: Health Check
        run: |
          echo "üè• Running health checks..."
          
          # Direct IP check
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 http://${{ steps.ec2.outputs.ip }} || echo "000")
          echo "HTTP (IP): $HTTP_CODE"
          
          # Domain check (may take time for DNS)
          DOMAIN_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 https://${{ vars.DOMAIN_NAME }} || echo "000")
          echo "HTTPS (Domain): $DOMAIN_CODE"
          
          if [ "$HTTP_CODE" == "000" ] && [ "$DOMAIN_CODE" == "000" ]; then
            echo "‚ö†Ô∏è Services not responding yet. Check manually."
          else
            echo "‚úÖ Services responding!"
          fi

      - name: Update GitHub Secrets
        if: github.event.inputs.action != 'config-only'
        run: |
          echo "üìù To complete setup, run these commands locally:"
          echo ""
          echo "gh secret set EC2_HOST --body '${{ steps.ec2.outputs.ip }}'"
          echo "gh secret set EC2_SSH_KEY < <(cat path/to/ssh_key.pem)"

  # ============================================================================
  # SUMMARY
  # ============================================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-24.04
    needs: [terraform, ansible]
    if: always() && github.event.inputs.action != 'destroy'
    
    steps:
      - name: Generate Summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Infrastructure (Terraform)" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ needs.terraform.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- EC2 IP: \`${{ needs.terraform.outputs.ec2_ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Configuration (Ansible)" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ needs.ansible.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üåê Access Points" >> $GITHUB_STEP_SUMMARY
          echo "- **API**: https://api.${{ vars.DOMAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Traefik**: https://traefik.${{ vars.DOMAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Direct IP**: http://${{ needs.terraform.outputs.ec2_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.ansible.result }}" == "success" ]; then
            echo "### ‚úÖ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
            echo "Your infrastructure is ready. DNS propagation may take 1-5 minutes." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ö†Ô∏è Deployment Incomplete" >> $GITHUB_STEP_SUMMARY
            echo "Check the logs above for errors." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Notify Discord
        if: always()
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          status: ${{ needs.ansible.result }}
          title: "Full Stack Deployment"
          description: |
            **Terraform**: ${{ needs.terraform.result }}
            **Ansible**: ${{ needs.ansible.result }}
            **EC2 IP**: ${{ needs.terraform.outputs.ec2_ip }}
            **Domain**: https://${{ vars.DOMAIN_NAME }}
