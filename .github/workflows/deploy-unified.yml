name: Pro-Mata Unified Deployment

on:
  # Manual triggers
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        type: choice
        options: ['dev', 'prod']
        default: 'dev'
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options: ['deploy', 'health', 'status', 'destroy']
        default: 'deploy'
      force_rebuild:
        description: 'Force infrastructure rebuild'
        required: false
        type: boolean
        default: false

  # Automatic triggers
  push:
    branches: [main, dev]
    paths: 
      - 'envs/**'
      - 'iac/**'
      - 'cac/**'
      - 'scripts/**'

  # External triggers (Docker Hub, other repos)
  repository_dispatch:
    types:
      - deploy-dev-frontend
      - deploy-dev-backend
      - deploy-prod-frontend
      - deploy-prod-backend
      - docker-hub-auto-deploy
      - deploy-manual

env:
  TERRAFORM_VERSION: '1.8.0'
  ANSIBLE_VERSION: 'latest'

jobs:
  # Determine environment and configuration
  config:
    name: 🔍 Determine Configuration
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      action: ${{ steps.config.outputs.action }}
      force_rebuild: ${{ steps.config.outputs.force_rebuild }}
      backend_image: ${{ steps.config.outputs.backend_image }}
      frontend_image: ${{ steps.config.outputs.frontend_image }}
      triggered_by: ${{ steps.config.outputs.triggered_by }}
      
    steps:
      - name: Parse Configuration
        id: config
        run: |
          # Determine environment
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
            ACTION="${{ github.event.inputs.action }}"
            FORCE_REBUILD="${{ github.event.inputs.force_rebuild }}"
            TRIGGERED_BY="manual"
          elif [ "${{ github.event_name }}" = "push" ]; then
            ENV="dev"  # Always deploy to dev for now
            ACTION="deploy"
            FORCE_REBUILD="false"
            TRIGGERED_BY="push_${{ github.ref_name }}"
          else
            # repository_dispatch
            case "${{ github.event.action }}" in
              "deploy-prod-frontend"|"deploy-prod-backend")
                ENV="prod"
                ;;
              *)
                ENV="dev"
                ;;
            esac
            ACTION="deploy"
            FORCE_REBUILD="false"
            TRIGGERED_BY="${{ github.event.action }}"
          fi
          
          # Set Docker images based on environment and trigger
          case "${{ github.event.action }}" in
            "docker-hub-auto-deploy")
              BACKEND_IMAGE="${{ github.event.client_payload.backend_image || 'norohim/pro-mata-backend-dev:latest' }}"
              FRONTEND_IMAGE="${{ github.event.client_payload.frontend_image || 'norohim/pro-mata-frontend-dev:latest' }}"
              ;;
            "deploy-prod-frontend")
              BACKEND_IMAGE="norohim/pro-mata-backend-prod:latest"
              FRONTEND_IMAGE="${{ github.event.client_payload.frontend_image || 'norohim/pro-mata-frontend-prod:latest' }}"
              ;;
            "deploy-prod-backend")
              BACKEND_IMAGE="${{ github.event.client_payload.backend_image || 'norohim/pro-mata-backend-prod:latest' }}"
              FRONTEND_IMAGE="norohim/pro-mata-frontend-prod:latest"
              ;;
            *)
              if [ "$ENV" = "prod" ]; then
                BACKEND_IMAGE="norohim/pro-mata-backend-prod:latest"
                FRONTEND_IMAGE="norohim/pro-mata-frontend-prod:latest"
              else
                BACKEND_IMAGE="norohim/pro-mata-backend-dev:latest"
                FRONTEND_IMAGE="norohim/pro-mata-frontend-dev:latest"
              fi
              ;;
          esac
          
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "force_rebuild=$FORCE_REBUILD" >> $GITHUB_OUTPUT
          echo "backend_image=$BACKEND_IMAGE" >> $GITHUB_OUTPUT
          echo "frontend_image=$FRONTEND_IMAGE" >> $GITHUB_OUTPUT
          echo "triggered_by=$TRIGGERED_BY" >> $GITHUB_OUTPUT
          
          echo "🎯 Configuration:"
          echo "Environment: $ENV"
          echo "Action: $ACTION"
          echo "Triggered by: $TRIGGERED_BY"

  # Verify Docker images exist
  verify:
    name: 🔍 Verify Images
    runs-on: ubuntu-latest
    needs: config
    if: contains(needs.config.outputs.action, 'deploy')
    
    steps:
      - name: Verify Backend Image
        run: |
          echo "🐳 Verifying backend image: ${{ needs.config.outputs.backend_image }}"
          docker manifest inspect ${{ needs.config.outputs.backend_image }} || {
            echo "❌ Backend image not found!"
            exit 1
          }

      - name: Verify Frontend Image
        run: |
          echo "🐳 Verifying frontend image: ${{ needs.config.outputs.frontend_image }}"
          docker manifest inspect ${{ needs.config.outputs.frontend_image }} || {
            echo "❌ Frontend image not found!"
            exit 1
          }

  # Main deployment job - Terraform State Fetch + Ansible Deploy
  deploy:
    name: 🚀 Deploy via Terraform State + Ansible
    runs-on: ubuntu-latest
    needs: [config, verify]
    if: contains(needs.config.outputs.action, 'deploy')
    environment: ${{ needs.config.outputs.environment }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Tools
        run: |
          # Install required packages
          sudo apt update
          sudo apt install -y software-properties-common make unzip curl
          
          # Install Terraform binary (extract to temporary location to avoid conflicts)
          mkdir -p /tmp/terraform-install
          cd /tmp/terraform-install
          wget https://releases.hashicorp.com/terraform/${{ env.TERRAFORM_VERSION }}/terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip -O terraform-binary.zip
          unzip -o terraform-binary.zip
          sudo rm -rf /usr/local/bin/terraform 2>/dev/null || true
          sudo cp terraform /usr/local/bin/
          sudo chmod +x /usr/local/bin/terraform
          cd -
          rm -rf /tmp/terraform-install
          
          # Install Ansible
          sudo add-apt-repository --yes --update ppa:ansible/ansible
          sudo apt install -y ansible

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          
      - name: Set Azure Environment Variables for Terraform
        run: |
          # Parse AZURE_CREDENTIALS and set environment variables for Terraform
          CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
          CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          SUBSCRIPTION_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
          TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          
          echo "ARM_CLIENT_ID=$CLIENT_ID" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=$CLIENT_SECRET" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=$TENANT_ID" >> $GITHUB_ENV
          echo "ARM_USE_CLI=false" >> $GITHUB_ENV
          
          echo "✅ Azure Service Principal environment variables configured for Terraform"

      # Moved to Enhanced setup section below

      - name: Create Environment Configuration
        run: |
          # Create config.yml with secrets  
          cat > envs/${{ needs.config.outputs.environment }}/config.yml << EOF
          # Azure Configuration
          environment = "${{ needs.config.outputs.environment }}"
          project_name = "promata"
          domain_name = "promata.com.br"
          azure_resource_group = "rg-myproject-${{ needs.config.outputs.environment }}"
          azure_subscription_id = "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          azure_location = "eastus2"
          vm_size = "Standard_B2s"
          
          # Application Images
          backend_image = "${{ needs.config.outputs.backend_image }}"
          frontend_image = "${{ needs.config.outputs.frontend_image }}"
          database_base_image = "norohim/pro-mata-database-${{ needs.config.outputs.environment }}:latest"
          database_infrastructure_image = "norohim/pro-mata-database-infrastructure-${{ needs.config.outputs.environment }}:latest"
          
          # Replicas
          backend_replicas = 1
          frontend_replicas = 1
          
          # Database
          postgres_db = "promata_${{ needs.config.outputs.environment }}"
          postgres_user = "promata"
          
          # Cloudflare (optional)
          cloudflare_api_token = "${{ secrets.CLOUDFLARE_API_TOKEN || 'null' }}"
          cloudflare_zone_id = "${{ secrets.CLOUDFLARE_ZONE_ID || 'null' }}"
          enable_cloudflare_dns = false
          
          # Analytics Configuration
          enable_analytics = true
          umami_website_id = "${{ secrets.UMAMI_WEBSITE_ID || 'dev-website-id' }}"
          umami_hash_salt = "${{ secrets.UMAMI_HASH_SALT || 'default-salt' }}"
          umami_db_password = "${{ secrets.UMAMI_DB_PASSWORD || 'dev-password' }}"
          
          # Storage
          storage_account_name = "promatadevstg"
          EOF

      - name: Setup Ansible Vault (Enhanced)
        run: |
          # Setup vault password file
          echo "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" > .vault_password
          chmod 600 .vault_password
          # Create symlink for Makefile compatibility
          ln -sf .vault_password .vault_pass
          
          # Initialize vault if needed (first time)
          ./scripts/vault/vault-easy.sh setup || echo "Vault already setup"
          
          # Initialize environment secrets if they don't exist
          mkdir -p "envs/${{ needs.config.outputs.environment }}/secrets"
          if [ ! -f "envs/${{ needs.config.outputs.environment }}/secrets/vault.yml" ]; then
            echo "🔐 Creating minimal vault file for ${{ needs.config.outputs.environment }}"
            echo "# Minimal vault for CI/CD" > "envs/${{ needs.config.outputs.environment }}/secrets/vault.yml"
            echo 'postgres_password: "ci_cd_password"' >> "envs/${{ needs.config.outputs.environment }}/secrets/vault.yml"
            echo 'jwt_secret: "ci_cd_jwt_secret"' >> "envs/${{ needs.config.outputs.environment }}/secrets/vault.yml"
            # Encrypt the file
            ansible-vault encrypt "envs/${{ needs.config.outputs.environment }}/secrets/vault.yml" --vault-password-file .vault_password
            echo "✅ Vault file created and encrypted"
          else
            echo "✅ Vault file already exists"
          fi

      - name: Import Existing IPs (IP Preservation)
        run: |
          echo "🔒 Importing existing Azure IPs to preserve them..."
          ./scripts/iac/import-existing-ips.sh ${{ needs.config.outputs.environment }} || echo "⚠️ IPs might already be imported"

      - name: Fetch Infrastructure State via Terraform
        if: contains(needs.config.outputs.action, 'deploy')
        run: |
          echo "🔍 Fetching infrastructure state and information via Terraform..."
          cd iac/deployments/${{ needs.config.outputs.environment }}
          
          # Initialize Terraform to read state
          terraform init -backend-config=../../../envs/${{ needs.config.outputs.environment }}/backend.hcl
          
          # Fetch current state - no apply, just read outputs
          echo "📊 Reading Terraform state..."
          terraform refresh -var-file=terraform.tfvars
          
          echo "✅ Infrastructure state fetched successfully"

      - name: Extract SSH Keys and Infrastructure Info
        if: contains(needs.config.outputs.action, 'deploy')
        run: |
          echo "🔑 Extracting SSH keys and infrastructure information..."
          make extract-ssh-keys ENV=${{ needs.config.outputs.environment }}
          make update-inventory ENV=${{ needs.config.outputs.environment }}
          echo "✅ SSH keys and inventory updated"

      - name: Update Production Images in Environment Config
        if: contains(needs.config.outputs.action, 'deploy')
        run: |
          echo "🐳 Updating production images in environment configuration..."
          
          # Update the config.yml with new image versions
          sed -i "s|backend_image = \".*\"|backend_image = \"${{ needs.config.outputs.backend_image }}\"|" envs/${{ needs.config.outputs.environment }}/config.yml
          sed -i "s|frontend_image = \".*\"|frontend_image = \"${{ needs.config.outputs.frontend_image }}\"|" envs/${{ needs.config.outputs.environment }}/config.yml
          
          echo "✅ Environment config updated with latest images"
          echo "Backend: ${{ needs.config.outputs.backend_image }}"
          echo "Frontend: ${{ needs.config.outputs.frontend_image }}"

      - name: Deploy Application Stack via Ansible
        if: contains(needs.config.outputs.action, 'deploy')
        run: |
          echo "🚀 Deploying application stack via Ansible..."
          make deploy-ansible ENV=${{ needs.config.outputs.environment }}
          echo "✅ Application deployment completed via Ansible"
        timeout-minutes: 30

      - name: Execute Other Actions
        if: "!contains(needs.config.outputs.action, 'deploy')"
        run: |
          case "${{ needs.config.outputs.action }}" in
            "health")
              make health ENV=${{ needs.config.outputs.environment }}
              ;;
            "status")
              make quick-status ENV=${{ needs.config.outputs.environment }}
              ;;
          esac
        timeout-minutes: 10


      - name: Health Check & Cleanup
        if: contains(needs.config.outputs.action, 'deploy')
        run: |
          echo "🏥 Running health checks..."
          make health ENV=${{ needs.config.outputs.environment }}
          
          echo "🧹 Cleaning up deprecated files..."
          make cleanup-deprecated || echo "Cleanup completed"
          
          echo "📊 Final deployment status..."
          make quick-status ENV=${{ needs.config.outputs.environment }}
        timeout-minutes: 10

      - name: Post-Deployment Validation
        if: contains(needs.config.outputs.action, 'deploy')
        run: |
          echo "🔍 Validating CI/CD setup..."
          ./scripts/ci-cd/validate-setup.sh ${{ needs.config.outputs.environment }} || echo "Validation completed with warnings"

  # Destroy job (separate for safety)
  destroy:
    name: 💥 Destroy Infrastructure
    runs-on: ubuntu-latest
    needs: config
    if: contains(needs.config.outputs.action, 'destroy')
    environment: ${{ needs.config.outputs.environment }}-destroy
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        run: |
          wget https://releases.hashicorp.com/terraform/${{ env.TERRAFORM_VERSION }}/terraform_${{ env.TERRAFORM_VERSION }}_linux_amd64.zip -O terraform.zip
          unzip -o terraform.zip || true
          sudo mv terraform /usr/local/bin/
          chmod +x /usr/local/bin/terraform

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          
      - name: Set Azure Environment Variables for Terraform
        run: |
          # Parse AZURE_CREDENTIALS and set environment variables for Terraform
          CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
          CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          SUBSCRIPTION_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
          TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          
          echo "ARM_CLIENT_ID=$CLIENT_ID" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=$CLIENT_SECRET" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=$TENANT_ID" >> $GITHUB_ENV
          echo "ARM_USE_CLI=false" >> $GITHUB_ENV

      - name: Destroy Infrastructure
        run: |
          make destroy-${{ needs.config.outputs.environment }}

  # Summary and notifications
  summary:
    name: 📋 Deployment Summary
    runs-on: ubuntu-latest
    needs: [config, deploy, destroy]
    if: always()
    
    steps:
      - name: Generate Summary
        run: |
          echo "## 🎉 Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${{ needs.config.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Action** | ${{ needs.config.outputs.action }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered By** | ${{ needs.config.outputs.triggered_by }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Backend Image** | ${{ needs.config.outputs.backend_image }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Frontend Image** | ${{ needs.config.outputs.frontend_image }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ (needs.deploy.result == 'success' || needs.destroy.result == 'success') && '✅ SUCCESS' || '❌ FAILED' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **IP Preservation** | ✅ ACTIVE |" >> $GITHUB_STEP_SUMMARY
          echo "| **Vault Management** | ✅ ACTIVE |" >> $GITHUB_STEP_SUMMARY
          echo "| **DNS Optimization** | ✅ CLOUDFLARE PROXY |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.config.outputs.environment }}" = "dev" ]; then
            echo "### 🔧 Development URLs (IP: 135.119.195.249 - RESERVED)" >> $GITHUB_STEP_SUMMARY
            echo "- **Frontend**: https://promata.com.br" >> $GITHUB_STEP_SUMMARY
            echo "- **API**: https://api.promata.com.br" >> $GITHUB_STEP_SUMMARY
            echo "- **Traefik**: https://traefik.promata.com.br" >> $GITHUB_STEP_SUMMARY
            echo "- **Grafana**: https://grafana.promata.com.br" >> $GITHUB_STEP_SUMMARY
            echo "- **Prometheus**: https://prometheus.promata.com.br" >> $GITHUB_STEP_SUMMARY
            echo "- **Analytics**: https://analytics.promata.com.br" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🛡️ Security Features Active:" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Static IP Reservation (Azure)" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Cloudflare Proxy (Zero DNS propagation)" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Ansible Vault Encryption" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Shared Terraform State" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Notify Discord
        if: always()
        run: |
          # Add Discord notification logic here
          echo "Would notify Discord about deployment status"
