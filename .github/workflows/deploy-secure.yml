# Secure CI/CD Pipeline - Pro-Mata Infrastructure
name: Deploy Infrastructure (Secure)

on:
  push:
    branches: [main]
    paths: ['terraform/**', 'ansible/**', 'environments/**']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options: [dev, staging, prod]
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options: [deploy, plan, destroy]

env:
  ARM_USE_AZUREAD: true
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

jobs:
  # Security validation job
  security-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Check for exposed secrets
        run: |
          echo "🔍 Scanning for potential secret exposure..."
          
          # Check if any .env files contain actual secrets (not templates)
          if find . -name "*.env*" -not -name "*.template" -not -name "*.example" | grep -v ".gitignore" | head -10; then
            echo "⚠️  Found .env files that might contain secrets"
            exit 1
          fi
          
          # Check for common secret patterns
          if grep -r "password.*=" . --include="*.tf" --include="*.yml" --include="*.yaml" | grep -v "template" | head -5; then
            echo "❌ Found potential hardcoded passwords"
            exit 1
          fi
          
          echo "✅ No obvious secret exposure detected"

      - name: Validate required secrets
        run: |
          echo "🔐 Validating CI/CD secrets availability..."
          
          required_secrets=(
            "AZURE_SUBSCRIPTION_ID"
            "AZURE_CLIENT_ID" 
            "AZURE_CLIENT_SECRET"
            "AZURE_TENANT_ID"
            "POSTGRES_PASSWORD"
            "JWT_SECRET"
            "DUCKDNS_TOKEN"
          )
          
          missing_secrets=()
          for secret in "${required_secrets[@]}"; do
            if [[ -z "${!secret}" ]]; then
              missing_secrets+=("$secret")
            fi
          done
          
          if [[ ${#missing_secrets[@]} -gt 0 ]]; then
            echo "❌ Missing required secrets: ${missing_secrets[*]}"
            echo "Please add these to GitHub repository secrets"
            exit 1
          fi
          
          echo "✅ All required secrets are available"

  # Terraform plan/apply job
  terraform:
    needs: security-check
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.0

      - name: Setup Security Environment
        run: |
          echo "🔐 Setting up secure environment for CI/CD..."
          chmod +x scripts/setup-security.sh
          
          # Load environment in CI mode (uses GitHub Secrets)
          ./scripts/setup-security.sh ${{ github.event.inputs.environment || 'dev' }} ci
        env:
          # Pass all secrets as environment variables
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_REPLICA_PASSWORD: ${{ secrets.POSTGRES_REPLICA_PASSWORD }}
          PGLADMIN_PASSWORD: ${{ secrets.PGADMIN_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          TRAEFIK_AUTH_USERS: ${{ secrets.TRAEFIK_AUTH_USERS }}
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          DUCKDNS_TOKEN: ${{ secrets.DUCKDNS_TOKEN }}
          TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}

      - name: Terraform Init
        working-directory: environments/${{ github.event.inputs.environment || 'dev' }}/azure
        run: terraform init

      - name: Terraform Plan
        working-directory: environments/${{ github.event.inputs.environment || 'dev' }}/azure
        run: |
          terraform plan \
            -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}" \
            -out=tfplan
        
      - name: Terraform Apply
        if: github.event.inputs.action != 'plan' && github.event.inputs.action != 'destroy'
        working-directory: environments/${{ github.event.inputs.environment || 'dev' }}/azure
        run: terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        working-directory: environments/${{ github.event.inputs.environment || 'dev' }}/azure
        run: |
          echo "🗑️  DESTROYING INFRASTRUCTURE"
          echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
          
          terraform destroy -auto-approve \
            -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}"

      - name: Save Terraform Outputs
        if: github.event.inputs.action != 'destroy'
        working-directory: environments/${{ github.event.inputs.environment || 'dev' }}/azure
        run: |
          terraform output -json > terraform-outputs.json
          echo "Terraform outputs saved for Ansible"

      - name: Upload Terraform Outputs
        if: github.event.inputs.action != 'destroy'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ github.event.inputs.environment || 'dev' }}
          path: environments/${{ github.event.inputs.environment || 'dev' }}/azure/terraform-outputs.json

  # Ansible configuration job
  ansible:
    needs: terraform
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'destroy' && github.event.inputs.action != 'plan'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible docker

      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs-${{ github.event.inputs.environment || 'dev' }}
          path: ./

      - name: Setup Secure Environment for Ansible
        run: |
          echo "🔐 Setting up secure environment for Ansible..."
          chmod +x scripts/setup-security.sh
          
          # Create Ansible vault file with secrets
          cat > ansible/inventory/${{ github.event.inputs.environment || 'dev' }}/group_vars/vault.yml << EOF
          # Encrypted Ansible Vault - Generated by CI/CD
          vault_postgres_password: ${{ secrets.POSTGRES_PASSWORD }}
          vault_postgres_replica_password: ${{ secrets.POSTGRES_REPLICA_PASSWORD }}
          vault_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
          vault_jwt_secret: ${{ secrets.JWT_SECRET }}
          vault_traefik_auth_users: ${{ secrets.TRAEFIK_AUTH_USERS }}
          vault_grafana_admin_password: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          vault_duckdns_token: ${{ secrets.DUCKDNS_TOKEN }}
          vault_acme_email: admin@promata.dev
          vault_duckdns_domain: promata-${{ github.event.inputs.environment || 'dev' }}
          EOF

      - name: Update Ansible Inventory with Terraform Outputs
        run: |
          echo "📋 Updating Ansible inventory with Terraform outputs..."
          
          # Extract IPs from Terraform outputs
          MANAGER_IP=$(jq -r '.swarm_manager_public_ip.value' terraform-outputs.json)
          WORKER_IP=$(jq -r '.swarm_worker_private_ip.value' terraform-outputs.json)
          
          # Update inventory file
          sed -i "s/{{ manager_public_ip }}/$MANAGER_IP/g" ansible/inventory/${{ github.event.inputs.environment || 'dev' }}/hosts.yml
          sed -i "s/{{ manager_private_ip }}/$MANAGER_IP/g" ansible/inventory/${{ github.event.inputs.environment || 'dev' }}/hosts.yml
          sed -i "s/{{ worker_private_ip }}/$WORKER_IP/g" ansible/inventory/${{ github.event.inputs.environment || 'dev' }}/hosts.yml
          
          echo "✅ Ansible inventory updated"

      - name: Wait for VMs to be ready
        run: |
          echo "⏳ Waiting for VMs to complete cloud-init..."
          sleep 180  # Give VMs time to complete cloud-init

      - name: Run Ansible Playbook
        working-directory: ansible
        run: |
          echo "🔧 Configuring infrastructure with Ansible..."
          
          # Run the main playbook
          ansible-playbook \
            -i inventory/${{ github.event.inputs.environment || 'dev' }}/hosts.yml \
            playbooks/site.yml \
            --timeout 300
        env:
          ANSIBLE_HOST_KEY_CHECKING: False

  # Notification job
  notify:
    needs: [terraform, ansible]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Notify Deployment Status
        run: |
          if [[ "${{ needs.terraform.result }}" == "success" && "${{ needs.ansible.result }}" == "success" ]]; then
            echo "✅ Deployment completed successfully!"
            echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
            echo "Action: ${{ github.event.inputs.action || 'deploy' }}"
          else
            echo "❌ Deployment failed!"
            echo "Terraform: ${{ needs.terraform.result }}"
            echo "Ansible: ${{ needs.ansible.result }}"
          fi