# Pro-Mata Development Complete Stack - Generated from Ansible Template
# Environment: {{ ansible_environment | default('development') }}
# Generated: {{ ansible_date_time.iso8601 }}
# Comprehensive development environment with monitoring, analytics, and HA database
version: "3.8"

networks:
  promata_public:
    external: true
  promata_internal:
    external: true
  promata_database:
    external: true

services:

  traefik:
    image: traefik:v3.0
    command:
      # API e Dashboard
      - --api.dashboard=true
      - --api.debug=false
      - --api.insecure=false
      
      # Entrypoints
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --entrypoints.traefik.address=:8080
      
      # Providers - CORRIGIDO para Docker Swarm
      - --providers.swarm=true
      - --providers.swarm.exposedbydefault=false
      - --providers.swarm.endpoint=unix:///var/run/docker.sock
      - --providers.swarm.watch=true
      
      # Certificados Let's Encrypt
      - --certificatesresolvers.letsencrypt.acme.httpchallenge=true
      - --certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web
      - --certificatesresolvers.letsencrypt.acme.email={{ acme_email }}
      - --certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json
{% if ansible_environment == 'prod' %}
      - --certificatesresolvers.letsencrypt.acme.caserver=https://acme-v02.api.letsencrypt.org/directory
{% else %}
      - --certificatesresolvers.letsencrypt.acme.caserver=https://acme-v02.api.letsencrypt.org/directory
{% endif %}
      
      # Certificados Let's Encrypt Staging (para testes)
      - --certificatesresolvers.letsencrypt-staging.acme.httpchallenge=true
      - --certificatesresolvers.letsencrypt-staging.acme.httpchallenge.entrypoint=web
      - --certificatesresolvers.letsencrypt-staging.acme.email={{ acme_email }}
      - --certificatesresolvers.letsencrypt-staging.acme.storage=/letsencrypt/acme-staging.json
      - --certificatesresolvers.letsencrypt-staging.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory
      
      # Logs e Métricas
      - --log.level={{ traefik_log_level | default('INFO') }}
      - --accesslog=true
      - --accesslog.filepath=/logs/access.log
      - --metrics.prometheus=true
      - --metrics.prometheus.addentrypointslabels=true
      - --metrics.prometheus.addserviceslabels=true
      
      # Segurança
      - --global.sendanonymoususage=false
      - --serversTransport.insecureSkipVerify=false
      
    ports:
      - target: 80
        published: 80
        mode: host
      - target: 443
        published: 443
        mode: host
      - target: 8080
        published: 8080
        mode: host
        
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik_letsencrypt:/letsencrypt
      
    networks:
      - promata_public
      
    environment:
      - ACME_EMAIL={{ acme_email }}
      - TRAEFIK_LOG_LEVEL={{ traefik_log_level | default('INFO') }}
      
    deploy:
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
      labels:
        - traefik.enable=true
        - traefik.docker.network=promata_public
        
        # Middleware para redirects HTTPS
        - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https
        - traefik.http.middlewares.redirect-to-https.redirectscheme.permanent=true
        
        # Middleware de segurança - MELHORADO
        - traefik.http.middlewares.security-headers.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.middlewares.security-headers.headers.sslredirect=true
        - traefik.http.middlewares.security-headers.headers.stsseconds=31536000
        - traefik.http.middlewares.security-headers.headers.stsincludesubdomains=true
        - traefik.http.middlewares.security-headers.headers.stspreload=true
        - traefik.http.middlewares.security-headers.headers.forcestshheader=true
        - traefik.http.middlewares.security-headers.headers.contenttypenosniff=true
        - traefik.http.middlewares.security-headers.headers.frameoptions=DENY
        - traefik.http.middlewares.security-headers.headers.referrerpolicy=strict-origin-when-cross-origin
        
        # Middleware de autenticação para dashboard
        - traefik.http.middlewares.traefik-auth.basicauth.users={{ traefik_auth_users }}
        
        # Router global para redirect HTTP -> HTTPS
        - traefik.http.routers.http-catchall.rule=hostregexp(`{host:.+}`)
        - traefik.http.routers.http-catchall.entrypoints=web
        - traefik.http.routers.http-catchall.middlewares=redirect-to-https
        
        # Dashboard do Traefik - CORRIGIDO
        - traefik.http.routers.traefik-dashboard.rule=Host(`traefik.{{ domain_name }}`)
        - traefik.http.routers.traefik-dashboard.entrypoints=websecure
        - traefik.http.routers.traefik-dashboard.tls.certresolver=letsencrypt
        - traefik.http.routers.traefik-dashboard.tls=true
        - traefik.http.routers.traefik-dashboard.middlewares=traefik-auth,security-headers
        - traefik.http.routers.traefik-dashboard.service=api@internal

  # === DATABASE CLUSTER ===
  postgres-primary:
    image: {{ database_image | default('norohim/pro-mata-database-infrastructure:latest') }}
    environment:
      - POSTGRES_DB={{ postgres_db }}
      - POSTGRES_USER={{ postgres_user }}
      - POSTGRES_PASSWORD={{ postgres_password }}
      - POSTGRES_REPLICATION_USER={{ postgres_replica_user }}
      - POSTGRES_REPLICATION_PASSWORD={{ postgres_replica_password }}
      - PGUSER={{ postgres_user }}
      - POSTGRES_INITDB_ARGS=--auth-host=md5
      - POSTGRES_HOST_AUTH_METHOD=md5
      - POSTGRES_ROLE=primary
    volumes:
      - postgres_primary_data:/var/lib/postgresql/data
      - postgres_config:/etc/postgresql
    networks:
      - promata_database
      - promata_internal
    deploy:
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          memory: 1G
          cpus: '0.8'
        reservations:
          memory: 512M
          cpus: '0.2'
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U {{ postgres_user }} -d {{ postgres_db }}"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  postgres-replica:
    image: {{ database_image | default('norohim/pro-mata-database-infrastructure:latest') }}
    environment:
      - POSTGRES_DB={{ postgres_db }}
      - POSTGRES_USER={{ postgres_user }}
      - POSTGRES_PASSWORD={{ postgres_password }}
      - POSTGRES_REPLICATION_USER={{ postgres_replica_user }}
      - POSTGRES_REPLICATION_PASSWORD={{ postgres_replica_password }}
      - PGUSER={{ postgres_user }}
      - POSTGRES_HOST_AUTH_METHOD=md5
      - POSTGRES_ROLE=replica
      - POSTGRES_PRIMARY_HOST=postgres-primary
      - POSTGRES_PRIMARY_PORT=5432
    volumes:
      - postgres_replica_data:/var/lib/postgresql/data
      - postgres_config:/etc/postgresql
    networks:
      - promata_database
    depends_on:
      - postgres-primary
    deploy:
      placement:
        constraints:
          - node.labels.database.replica == true
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3
      resources:
        limits:
          memory: {{ postgres_replica_memory_limit | default('600M') }}
          cpus: {{ postgres_replica_cpu_limit | default('0.5') }}
        reservations:
          memory: {{ postgres_replica_memory_reservation | default('384M') }}
          cpus: {{ postgres_replica_cpu_reservation | default('0.25') }}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U {{ postgres_user }} -d {{ postgres_db }}"]
      interval: 15s
      timeout: 5s
      retries: 3

  # === CONNECTION POOLING ===
  pgbouncer:
    image: pgbouncer/pgbouncer:latest
    environment:
      - DATABASES_HOST=postgres-primary
      - DATABASES_PORT=5432
      - DATABASES_USER={{ postgres_user }}
      - DATABASES_PASSWORD={{ postgres_password }}
      - DATABASES_DBNAME={{ postgres_db }}
      - POOL_MODE={{ pgbouncer_pool_mode | default('transaction') }}
      - SERVER_RESET_QUERY=DISCARD ALL
      - MAX_CLIENT_CONN={{ pgbouncer_max_client_conn | default('200') }}
      - DEFAULT_POOL_SIZE={{ pgbouncer_pool_size | default('25') }}
      - RESERVE_POOL_SIZE={{ reserve_pool_size | default(5) }}
      - RESERVE_POOL_TIMEOUT={{ reserve_pool_timeout | default(5) }}
      - LOG_CONNECTIONS={{ log_connections | default(1) }}
      - LOG_DISCONNECTIONS={{ log_disconnections | default(1) }}
      - SERVER_LIFETIME=3600
      - SERVER_IDLE_TIMEOUT=600
      - LISTEN_ADDR=0.0.0.0
      - LISTEN_PORT=6432
    networks:
      - promata_database
      - promata_internal
    depends_on:
      - postgres-primary
    deploy:
      replicas: {{ pgbouncer_replicas | default(1) }}
      placement:
        max_replicas_per_node: 1
      restart_policy:
        condition: on-failure
        delay: 5s
      resources:
        limits:
          memory: 256M
          cpus: '0.25'
        reservations:
          memory: 128M
          cpus: '0.1'
    healthcheck:
      test: ["CMD-SHELL", "nc -z 127.0.0.1 6432"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # === APPLICATION SERVICES ===
  frontend:
    image: {{ frontend_image }}
    environment:
      - NODE_ENV={{ 'production' if ansible_environment == 'prod' else 'development' }}
      - VITE_API_URL=https://api.{{ domain_name }}
      - VITE_APP_ENV={{ ansible_environment | default('development') }}
      - VITE_UMAMI_URL=https://analytics.{{ domain_name }}
      - VITE_UMAMI_WEBSITE_ID={{ umami_website_id | default('') }}
      - VITE_UMAMI_SCRIPT_URL=https://analytics.{{ domain_name }}/script.js
      - VITE_ENABLE_ANALYTICS={{ vite_enable_analytics | default(true) }}
    networks:
      - promata_public
      - promata_internal
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      replicas: {{ frontend_replicas | default(1) }}
      placement:
        max_replicas_per_node: 1
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
      resources:
        limits:
          memory: {{ frontend_memory_limit | default('1G') }}
          cpus: {{ frontend_cpu_limit | default('1.0') }}
        reservations:
          memory: {{ frontend_memory_reservation | default('512M') }}
          cpus: {{ frontend_cpu_reservation | default('0.5') }}
      labels:
        - traefik.enable=true
        - traefik.docker.network=promata_public
        - traefik.http.routers.frontend.rule=Host(`{{ domain_name }}`)
        - traefik.http.routers.frontend.entrypoints=websecure
        - traefik.http.routers.frontend.tls.certresolver=letsencrypt
        - traefik.http.routers.frontend.tls=true
        - traefik.http.services.frontend.loadbalancer.server.port=3000

  backend:
    image: {{ backend_image }}
    environment:
      # Configuração básica
      - NODE_ENV={{ 'production' if ansible_environment == 'prod' else 'development' }}
      - PORT=3000
      - API_SUBDOMAIN=api 
      
      # Configuração de banco - CORRIGIDA
      - JWT_SECRET={{ jwt_secret }}
      - JWT_EXPIRES_IN={{ jwt_expires_in | default('1h') }}
      
      # Database URL com PgBouncer
      - DATABASE_URL=postgresql://{{ postgres_user }}:{{ postgres_password }}@pgbouncer:6432/{{ postgres_db }}
      
      # Configuração alternativa para conexão direta (para debug)
      - DATABASE_HOST=postgres-primary
      - DATABASE_PORT=5432
      - DATABASE_NAME={{ postgres_db }}
      - DATABASE_USER={{ postgres_user }}
      - DATABASE_PASSWORD={{ postgres_password }}
      
      # Pool de conexão
      - DATABASE_POOL_MIN={{ database_pool_min | default(2) }}
      - DATABASE_POOL_MAX={{ database_pool_max | default(10) }}
      - DATABASE_POOL_IDLE_TIMEOUT={{ database_pool_idle_timeout | default(30000) }}
      
      # CORS
      - CORS_ORIGIN=https://{{ domain_name }},https://traefik.{{ domain_name }}
      - CORS_CREDENTIALS={{ cors_credentials | default(true) }}
      
      # Analytics (opcional)
      - UMAMI_URL=https://analytics.{{ domain_name }}
      - UMAMI_WEBSITE_ID={{ umami_website_id | default('') }}
      - UMAMI_API_KEY={{ umami_api_key | default('') }}
      - ENABLE_ANALYTICS={{ enable_analytics | default(false) }}
      
      # Logs e Debug
      - LOG_LEVEL={{ log_level | default('info') }}
      - DEBUG={{ debug | default(false) }}
      
      # Health check
      - HEALTH_CHECK_ENDPOINT={{ health_check_endpoint | default('/health') }}
      
    networks:
      - promata_public
      - promata_internal  
      - promata_database
      
    depends_on:
      - pgbouncer

    deploy:
      replicas: {{ backend_replicas | default(1) }}
      placement:
        max_replicas_per_node: 1
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 5
        window: 120s
      resources:
        limits:
          memory: {{ backend_memory_limit | default('800M') }}
          cpus: {{ backend_cpu_limit | default('0.8') }}
        reservations:
          memory: {{ backend_memory_reservation | default('300M') }}
          cpus: {{ backend_cpu_reservation | default('0.2') }}
      labels:
        - traefik.enable=true
        - traefik.docker.network=promata_public
        
        # Router principal
        - traefik.http.routers.backend.rule=Host(`api.{{ domain_name }}`)
        - traefik.http.routers.backend.entrypoints=websecure
        - traefik.http.routers.backend.tls.certresolver=letsencrypt
        - traefik.http.routers.backend.tls=true
        - traefik.http.routers.backend.middlewares=security-headers
        
        # Service configuration
        - traefik.http.services.backend.loadbalancer.server.port=3000
        - traefik.http.services.backend.loadbalancer.healthcheck.path=/health
        - traefik.http.services.backend.loadbalancer.healthcheck.interval=30s
        - traefik.http.services.backend.loadbalancer.healthcheck.timeout=10s
        
        # CORS headers para API
        - traefik.http.middlewares.api-cors.headers.accesscontrolexposeheaders=*

  # === MONITORING STACK ===
  node-exporter:
    image: prom/node-exporter:latest
    command:
      - '--path.rootfs=/host'
      - '--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/)'
      - '--collector.systemd'
      - '--collector.processes'
      - '--collector.cpu'
      - '--collector.meminfo'
      - '--collector.diskstats'
      - '--collector.netdev'
      - '--collector.loadavg'
    volumes:
      - /:/host:ro,rslave
      - /var/run/dbus/system_bus_socket:/var/run/dbus/system_bus_socket:ro
    networks:
      - promata_internal
    deploy:
      mode: global
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 128M
          cpus: '0.1'
        reservations:
          memory: 64M
          cpus: '0.05'
      labels:
        - prometheus.io/scrape=true
        - prometheus.io/port=9100

  prometheus:
    image: prom/prometheus:latest
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time={{ prometheus_retention | default('200h') }}'
      - '--web.enable-lifecycle'
      - '--web.enable-admin-api'
    volumes:
      - prometheus_data:/prometheus
      - /opt/promata/configs/prometheus:/etc/prometheus:ro
    networks:
      - promata_internal
      - promata_public
    depends_on:
      - node-exporter
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 512M
          cpus: '0.25'
      labels:
        - traefik.enable=true
        - traefik.docker.network=promata_public
        - traefik.http.routers.prometheus.rule=Host(`prometheus.{{ domain_name }}`)
        - traefik.http.routers.prometheus.entrypoints=websecure
        - traefik.http.routers.prometheus.tls.certresolver=letsencrypt
        - traefik.http.routers.prometheus.tls=true
        - traefik.http.services.prometheus.loadbalancer.server.port=9090
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:9090/-/healthy"]
      interval: 30s
      timeout: 10s
      retries: 3

  grafana:
    image: grafana/grafana:latest
    environment:
      - GF_SECURITY_ADMIN_USER={{ grafana_admin_user | default('admin') }}
      - GF_SECURITY_ADMIN_PASSWORD={{ grafana_admin_password | default(grafana_password) }}
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_USERS_ALLOW_ORG_CREATE=false
      - GF_SERVER_DOMAIN=grafana.{{ domain_name }}
      - GF_SERVER_ROOT_URL=https://grafana.{{ domain_name }}
      - GF_INSTALL_PLUGINS={{ grafana_plugins | default('grafana-piechart-panel,grafana-clock-panel') }}
    volumes:
      - grafana_data:/var/lib/grafana
      - /opt/promata/configs/grafana/datasources:/etc/grafana/provisioning/datasources:ro
      - /opt/promata/configs/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro
    networks:
      - promata_internal
      - promata_public
    depends_on:
      - prometheus
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
      labels:
        - traefik.enable=true
        - traefik.docker.network=promata_public
        - traefik.http.routers.grafana.rule=Host(`grafana.{{ domain_name }}`)
        - traefik.http.routers.grafana.entrypoints=websecure
        - traefik.http.routers.grafana.tls.certresolver=letsencrypt
        - traefik.http.routers.grafana.tls=true
        - traefik.http.services.grafana.loadbalancer.server.port=3000
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/api/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  # === ANALYTICS ===
  umami-db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB={{ umami_db_name }}
      - POSTGRES_USER={{ umami_db_user }}
      - POSTGRES_PASSWORD={{ umami_db_password }}
    volumes:
      - umami_db_data:/var/lib/postgresql/data
    networks:
      - promata_database
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U {{ umami_db_user }} -d {{ umami_db_name }}"]
      interval: 30s
      timeout: 10s
      retries: 3

  umami:
    image: ghcr.io/umami-software/umami:postgresql-latest
    environment:
      - DATABASE_URL=postgresql://{{ umami_db_user }}:{{ umami_db_password }}@umami-db:5432/{{ umami_db_name }}
      - DATABASE_TYPE=postgresql
      - APP_SECRET={{ umami_app_secret }}
      - HOSTNAME=0.0.0.0
      - PORT=3000
    networks:
      - promata_database
      - promata_public
    depends_on:
      - umami-db
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 256M
          cpus: '0.2'
        reservations:
          memory: 128M
          cpus: '0.1'
      labels:
        - traefik.enable=true
        - traefik.docker.network=promata_public
        - traefik.http.routers.umami.rule=Host(`analytics.{{ domain_name }}`)
        - traefik.http.routers.umami.entrypoints=websecure
        - traefik.http.routers.umami.tls.certresolver=letsencrypt
        - traefik.http.routers.umami.tls=true
        - traefik.http.services.umami.loadbalancer.server.port=3000
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/api/heartbeat || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  metabase:
    image: metabase/metabase:latest
    environment:
      - MB_DB_TYPE=postgres
      - MB_DB_DBNAME={{ postgres_db }}
      - MB_DB_PORT=5432
      - MB_DB_USER={{ postgres_user }}
      - MB_DB_PASS={{ postgres_password }}
      - MB_DB_HOST=postgres-primary
      - MB_ENCRYPTION_SECRET_KEY={{ metabase_secret_key }}
      - JAVA_OPTS=-Xmx768m -Xms256m
    volumes:
      - metabase_data:/metabase-data
    networks:
      - promata_database
      - promata_public
    depends_on:
      - pgbouncer
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 768M
          cpus: '0.75'
        reservations:
          memory: 384M
          cpus: '0.375'
      labels:
        - traefik.enable=true
        - traefik.docker.network=promata_public
        - traefik.http.routers.metabase.rule=Host(`metabase.{{ domain_name }}`)
        - traefik.http.routers.metabase.entrypoints=websecure
        - traefik.http.routers.metabase.tls.certresolver=letsencrypt
        - traefik.http.routers.metabase.tls=true
        - traefik.http.services.metabase.loadbalancer.server.port=3000

  pgadmin:
    image: dpage/pgadmin4:latest
    environment:
      - PGADMIN_DEFAULT_EMAIL={{ pgadmin_email }}
      - PGADMIN_DEFAULT_PASSWORD={{ pgadmin_password }}
      - PGADMIN_CONFIG_SERVER_MODE=True
      - PGADMIN_CONFIG_MASTER_PASSWORD_REQUIRED=False
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    networks:
      - promata_database
      - promata_public
    depends_on:
      - pgbouncer
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
      resources:
        limits:
          memory: 256M
          cpus: '0.2'
        reservations:
          memory: 128M
          cpus: '0.1'
      labels:
        - traefik.enable=true
        - traefik.docker.network=promata_public
        - traefik.http.routers.pgadmin.rule=Host(`pgadmin.{{ domain_name }}`)
        - traefik.http.routers.pgadmin.entrypoints=websecure
        - traefik.http.routers.pgadmin.tls.certresolver=letsencrypt
        - traefik.http.routers.pgadmin.tls=true
        - traefik.http.services.pgadmin.loadbalancer.server.port=80

networks:
  promata_public:
    external: true
  promata_internal:
    external: true
  promata_database:
    external: true

volumes:
  postgres_primary_data:
    driver: local
  postgres_replica_data:
    driver: local
  postgres_config:
    driver: local
  traefik_letsencrypt:
    driver: local
  prometheus_data:
    driver: local
  grafana_data:
    driver: local
  metabase_data:
    driver: local
  pgadmin_data:
    driver: local
  umami_db_data:
    driver: local

networks:
  database_tier:
    external: true
  app_tier:
    external: true
  proxy_tier:
    external: true
  monitoring_tier:
    external: true

volumes:
  postgres_primary_data:
    driver: local
{% if postgres_replica_count | default(0) | int > 0 %}
  postgres_replica_data:
    driver: local
{% endif %}
  postgres_backups:
    driver: local
{% if redis_enabled | default(true) %}
  redis_data:
    driver: local
{% endif %}
  traefik_letsencrypt:
    driver: local
{% if monitoring_enabled | default(true) %}
  prometheus_data:
    driver: local
  prometheus_config:
    driver: local
  grafana_data:
    driver: local
{% endif %}