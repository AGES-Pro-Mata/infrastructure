# Pro-Mata Stack Deployment Playbook
---
- name: Deploy Pro-Mata Stack
  hosts: managers
  become: true
  gather_facts: true
  
  vars_files:
    - "../inventory/{{ env | default('dev') }}/group_vars/all.yml"
  
  tasks:
    - name: Create Pro-Mata directories
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      loop:
        - /opt/promata/stacks
        - /opt/promata/configs
        - /opt/promata/configs/prometheus
        - /opt/promata/configs/grafana
        - /opt/promata/configs/grafana/dashboards
        - /opt/promata/configs/grafana/datasources
        - /opt/promata/configs/grafana/provisioning
        - /opt/promata/configs/grafana/provisioning/dashboards
        - /opt/promata/configs/grafana/provisioning/datasources
        - /opt/promata/logs
        - /opt/promata/data

    # Docker Swarm Setup
    - name: Disable live-restore for swarm mode
      lineinfile:
        path: /etc/docker/daemon.json
        regexp: '"live-restore": true'
        line: '  "live-restore": false'
        backup: yes
      register: docker_config_updated
      
    - name: Restart Docker if config changed
      systemd:
        name: docker
        state: restarted
      when: docker_config_updated.changed
      
    - name: Wait for Docker to restart
      pause:
        seconds: 10
      when: docker_config_updated.changed

    - name: Check if Docker Swarm is already initialized
      command: docker info --format '{{ "{{.Swarm.LocalNodeState}}" }}'
      register: swarm_status
      changed_when: false
      
    - name: Initialize Docker Swarm
      command: docker swarm init --advertise-addr {{ ansible_default_ipv4.address }}
      register: swarm_init
      when: swarm_status.stdout != "active"
      
    - name: Get worker join token
      command: docker swarm join-token worker -q
      register: worker_join_token
      when: swarm_status.stdout != "active"
      
    - name: Add database node labels to manager
      command: docker node update --label-add database.primary=true {{ ansible_hostname }}
      when: swarm_status.stdout != "active"

- name: Join workers to swarm
  hosts: workers
  become: true
  gather_facts: true
  
  tasks:
    - name: Disable live-restore for swarm mode on worker
      lineinfile:
        path: /etc/docker/daemon.json
        regexp: '"live-restore": true'
        line: '  "live-restore": false'
        backup: yes
      register: docker_config_updated_worker
      
    - name: Restart Docker on worker if config changed
      systemd:
        name: docker
        state: restarted
      when: docker_config_updated_worker.changed
      
    - name: Wait for Docker to restart on worker
      pause:
        seconds: 10
      when: docker_config_updated_worker.changed

    - name: Check if worker is already in swarm
      command: docker info --format '{{ "{{.Swarm.LocalNodeState}}" }}'
      register: worker_swarm_status
      changed_when: false
      
    - name: Join worker to swarm
      command: docker swarm join --token {{ hostvars[groups['managers'][0]]['worker_join_token']['stdout'] }} {{ hostvars[groups['managers'][0]]['ansible_default_ipv4']['address'] }}:2377
      when: worker_swarm_status.stdout != "active" and hostvars[groups['managers'][0]]['worker_join_token'] is defined

- name: Complete swarm setup and deploy stack
  hosts: managers
  become: true
  gather_facts: true
  
  vars_files:
    - "../inventory/{{ env | default('dev') }}/group_vars/all.yml"
  
  tasks:
    - name: Add database replica label to worker nodes
      command: docker node update --label-add database.replica=true {{ item }}
      loop: "{{ groups['workers'] | map('extract', hostvars, 'ansible_hostname') | list }}"
      when: groups['workers'] is defined
      ignore_errors: yes

    - name: Create Docker networks
      docker_network:
        name: "{{ item }}"
        driver: overlay
        scope: swarm
        attachable: true
      loop:
        - promata_public
        - promata_internal
        - promata_database

    - name: Copy stack file based on environment
      copy:
        src: "../../docker/stacks/{{ stack_file | default('dev-complete.yml') }}"
        dest: "/opt/promata/stacks/{{ stack_file | default('dev-complete.yml') }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Copy Prometheus configuration
      copy:
        src: "../../docker/configs/prometheus/prometheus.yml"
        dest: "/opt/promata/configs/prometheus/prometheus.yml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Copy Grafana configurations
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      loop:
        - src: "../../docker/configs/grafana/datasources/prometheus.yml"
          dest: "/opt/promata/configs/grafana/datasources/prometheus.yml"
        - src: "../../docker/configs/grafana/dashboards/dashboards.yml"
          dest: "/opt/promata/configs/grafana/dashboards/dashboards.yml"

    - name: Generate dev environment file
      template:
        src: "templates/dev.env.j2"
        dest: /opt/promata/.env
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'

    - name: Deploy Pro-Mata stack
      shell: |
        cd /opt/promata
        export $(cat .env | grep -v '^#' | grep -v '^$' | xargs)
        docker stack deploy -c stacks/{{ stack_file | default('dev-complete.yml') }} promata-{{ env | default('dev') }} --with-registry-auth
      register: stack_deploy_result
      
    - name: Display stack deployment result
      debug:
        var: stack_deploy_result.stdout_lines
      
    - name: Wait for stack services to initialize
      pause:
        seconds: 45
        prompt: "Waiting for Pro-Mata services to initialize..."

    - name: Verify stack deployment
      command: docker service ls --filter "label=com.docker.stack.namespace=promata-{{ env | default('dev') }}"
      register: stack_services
      
    - name: Display deployed services
      debug:
        var: stack_services.stdout_lines

    - name: Check critical services health
      command: docker service ps promata-{{ env | default('dev') }}_{{ item }} --no-trunc
      register: service_status
      loop:
        - traefik
        - postgres  
        - pgadmin
        - grafana
      ignore_errors: yes

    - name: Display critical service health
      debug:
        msg: "{{ item.item }} service status: {{ item.stdout_lines }}"
      loop: "{{ service_status.results }}"
      when: item.stdout_lines is defined

    - name: Test service connectivity
      uri:
        url: "https://{{ item }}.{{ domain_name }}"
        method: GET
        validate_certs: no
        timeout: 10
      register: service_connectivity
      loop:
        - grafana
        - pgadmin
      ignore_errors: yes

    - name: Display connectivity test results
      debug:
        msg: "Service {{ item.item }}: {{ 'ACCESSIBLE' if item.status == 200 or item.status == 308 else 'NOT ACCESSIBLE (' + item.status|string + ')' }}"
      loop: "{{ service_connectivity.results }}"
      when: item.status is defined

    - name: Display deployment summary
      debug:
        msg:
          - "üöÄ Pro-Mata dev environment deployment completed!"
          - "üåê Frontend: https://{{ domain_name }}"
          - "üîß API: https://api.{{ domain_name }}"
          - "üìä Grafana: https://grafana.{{ domain_name }}"
          - "üóÑÔ∏è  PgAdmin: https://pgadmin.{{ domain_name }}"
          - "üìä Traefik: https://traefik.{{ domain_name }}"
          - "üîê Simple passwords: admin/admin, promata/password123"