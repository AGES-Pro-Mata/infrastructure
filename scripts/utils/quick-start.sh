#!/bin/bash

# scripts/quick-start.sh
# Script de inicializa√ß√£o r√°pida do Pro-Mata Security System
# Autor: Sistema de Seguran√ßa Pro-Mata
# Vers√£o: 1.0.0

set -euo pipefail

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Configura√ß√µes
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Vari√°veis globais
INTERACTIVE=true
ENVIRONMENT="dev"
SETUP_MODE=false

# Fun√ß√£o de logging
log() {
    local level="$1"
    local message="$2"
    
    case "$level" in
        "INFO")
            echo -e "${CYAN}‚ÑπÔ∏è ${NC}$message"
            ;;
        "SUCCESS")
            echo -e "${GREEN}‚úÖ ${NC}$message"
            ;;
        "WARN")
            echo -e "${YELLOW}‚ö†Ô∏è ${NC}$message"
            ;;
        "ERROR")
            echo -e "${RED}‚ùå ${NC}$message"
            ;;
        "STEP")
            echo -e "${BLUE}‚ñ∂Ô∏è ${NC}$message"
            ;;
        *)
            echo -e "$message"
            ;;
    esac
}

# Banner do sistema
show_banner() {
    clear
    echo -e "${BLUE}"
    cat << 'EOF'
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó       ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù      ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù       ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
EOF
    echo -e "${NC}"
    echo -e "${CYAN}üîê Pro-Mata Security System - Quick Start${NC}"
    echo -e "${PURPLE}Sistema Completo de Monitoramento e Seguran√ßa${NC}"
    echo ""
}

# Verificar se o sistema j√° est√° inicializado
check_initialization() {
    if [[ ! -f "$PROJECT_ROOT/security/security-config.yml" ]]; then
        log "WARN" "Sistema n√£o inicializado. Executando inicializa√ß√£o autom√°tica..."
        SETUP_MODE=true
        return 1
    fi
    return 0
}

# Detectar ambiente automaticamente
detect_environment() {
    local detected_env="dev"
    
    # Verificar vari√°veis de ambiente
    if [[ -n "${ENVIRONMENT:-}" ]]; then
        detected_env="$ENVIRONMENT"
    elif [[ -f "$PROJECT_ROOT/.env.security" ]]; then
        detected_env=$(grep "^ENVIRONMENT=" "$PROJECT_ROOT/.env.security" | cut -d'=' -f2 | tr -d '"' || echo "dev")
    fi
    
    # Verificar hostname/dom√≠nio
    local hostname=$(hostname 2>/dev/null || echo "localhost")
    if [[ "$hostname" =~ staging ]]; then
        detected_env="staging"
    elif [[ "$hostname" =~ prod ]]; then
        detected_env="prod"
    fi
    
    ENVIRONMENT="$detected_env"
    log "INFO" "Ambiente detectado: $ENVIRONMENT"
}

# Verificar status do sistema
check_system_status() {
    log "STEP" "Verificando status do sistema..."
    
    local status_ok=true
    local issues=()
    
    # Verificar scripts execut√°veis
    local scripts=("security-scan.sh" "security-audit.sh" "security-monitor.sh" "rotate-secrets.sh")
    for script in "${scripts[@]}"; do
        if [[ ! -x "$PROJECT_ROOT/scripts/$script" ]]; then
            issues+=("Script n√£o execut√°vel: $script")
            status_ok=false
        fi
    done
    
    # Verificar depend√™ncias
    local deps=("curl" "jq" "openssl" "docker")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            issues+=("Depend√™ncia ausente: $dep")
            status_ok=false
        fi
    done
    
    # Verificar monitoramento ativo
    if pgrep -f "security-monitor.sh" > /dev/null; then
        log "SUCCESS" "Monitoramento: ATIVO"
    else
        log "WARN" "Monitoramento: INATIVO"
    fi
    
    # Verificar √∫ltimo scan
    local latest_scan=$(find "$PROJECT_ROOT/reports/security-scan" -name "*.txt" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2- || echo "")
    if [[ -n "$latest_scan" ]]; then
        local scan_age=$((($(date +%s) - $(stat -c %Y "$latest_scan")) / 3600))
        if [[ $scan_age -lt 24 ]]; then
            log "SUCCESS" "√öltimo scan: h√° ${scan_age}h"
        else
            log "WARN" "√öltimo scan: h√° ${scan_age}h (>24h)"
        fi
    else
        log "WARN" "Nenhum scan encontrado"
    fi
    
    # Verificar alertas
    local alert_count=$(find "$PROJECT_ROOT/monitoring" -name "alert-*.json" 2>/dev/null | wc -l)
    if [[ $alert_count -eq 0 ]]; then
        log "SUCCESS" "Alertas ativos: 0"
    else
        log "WARN" "Alertas ativos: $alert_count"
    fi
    
    if [[ "$status_ok" == "false" ]]; then
        echo ""
        log "ERROR" "Issues encontrados:"
        for issue in "${issues[@]}"; do
            echo -e "  ${RED}‚Ä¢ ${NC}$issue"
        done
        echo ""
    fi
    
    return $status_ok
}

# Menu principal interativo
show_main_menu() {
    echo ""
    echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${BLUE}‚ïë${NC}            MENU PRINCIPAL              ${BLUE}‚ïë${NC}"
    echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${CYAN}üîç VERIFICA√á√ïES E SCANS:${NC}"
    echo "  1) üîç Executar scan de seguran√ßa completo"
    echo "  2) üìã Executar auditoria de conformidade"
    echo "  3) üß™ Executar testes do sistema"
    echo "  4) üìä Verificar status geral"
    echo ""
    echo -e "${CYAN}üîß MONITORAMENTO:${NC}"
    echo "  5) üëÅÔ∏è  Iniciar monitoramento em tempo real"
    echo "  6) ‚èπÔ∏è  Parar monitoramento"
    echo "  7) üö® Verificar alertas recentes"
    echo ""
    echo -e "${CYAN}üîÑ OPERA√á√ïES:${NC}"
    echo "  8) üîë Rotacionar secrets"
    echo "  9) üíæ Criar backup completo"
    echo " 10) üîÑ Restaurar do backup"
    echo ""
    echo -e "${CYAN}üìä VISUALIZA√á√ÉO:${NC}"
    echo " 11) üìà Abrir dashboard de seguran√ßa"
    echo " 12) üìÑ Gerar relat√≥rio de seguran√ßa"
    echo " 13) üìù Ver logs recentes"
    echo ""
    echo -e "${CYAN}‚öôÔ∏è CONFIGURA√á√ÉO:${NC}"
    echo " 14) ‚öôÔ∏è  Configurar sistema"
    echo " 15) üßπ Limpeza e manuten√ß√£o"
    echo " 16) ‚ùì Ajuda e documenta√ß√£o"
    echo ""
    echo -e "${CYAN}0) üö™ Sair${NC}"
    echo ""
}

# Executar scan de seguran√ßa
run_security_scan() {
    log "STEP" "Iniciando scan de seguran√ßa completo..."
    
    echo ""
    echo "Tipos de scan dispon√≠veis:"
    echo "1) Completo (recomendado)"
    echo "2) Containers apenas"  
    echo "3) Depend√™ncias apenas"
    echo "4) Rede apenas"
    echo ""
    
    read -p "Escolha o tipo de scan [1]: " scan_choice
    scan_choice=${scan_choice:-1}
    
    local scan_type="all"
    case "$scan_choice" in
        1) scan_type="all" ;;
        2) scan_type="containers" ;;
        3) scan_type="dependencies" ;;
        4) scan_type="network" ;;
        *) scan_type="all" ;;
    esac
    
    echo ""
    log "INFO" "Executando scan tipo: $scan_type"
    
    if "$PROJECT_ROOT/scripts/security-scan.sh" --environment "$ENVIRONMENT" --type "$scan_type" --verbose; then
        log "SUCCESS" "Scan conclu√≠do com sucesso!"
        
        # Mostrar resumo
        local latest_report=$(find "$PROJECT_ROOT/reports/security-scan" -name "*.txt" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2- || echo "")
        if [[ -n "$latest_report" ]]; then
            echo ""
            log "INFO" "Resumo do scan:"
            if grep -q "CR√çTICAS:" "$latest_report"; then
                local critical=$(grep "CR√çTICAS:" "$latest_report" | awk '{print $2}' || echo "0")
                local high=$(grep "ALTAS:" "$latest_report" | awk '{print $2}' || echo "0")
                echo -e "  ${RED}‚Ä¢ Cr√≠ticas: $critical${NC}"
                echo -e "  ${YELLOW}‚Ä¢ Altas: $high${NC}"
            fi
        fi
    else
        log "ERROR" "Scan falhou. Verifique os logs para detalhes."
    fi
    
    pause_for_user
}

# Executar auditoria
run_security_audit() {
    log "STEP" "Executando auditoria de seguran√ßa..."
    
    if "$PROJECT_ROOT/scripts/security/security-audit.sh" --compliance-check --environment "$ENVIRONMENT" --verbose; then
        log "SUCCESS" "Auditoria conclu√≠da!"
    else
        log "ERROR" "Auditoria falhou. Verifique os logs."
    fi
    
    pause_for_user
}

# Executar testes
run_tests() {
    log "STEP" "Executando testes do sistema..."
    
    echo ""
    echo "Tipos de teste:"
    echo "1) R√°pidos (unit + integration)"
    echo "2) Completos (todos os testes)"
    echo ""
    
    read -p "Escolha [1]: " test_choice
    test_choice=${test_choice:-1}
    
    local test_args=""
    if [[ "$test_choice" == "1" ]]; then
        test_args="--quick"
    fi
    
    if "$PROJECT_ROOT/scripts/test-security.sh" --environment "$ENVIRONMENT" $test_args; then
        log "SUCCESS" "Testes conclu√≠dos!"
    else
        log "ERROR" "Alguns testes falharam."
    fi
    
    pause_for_user
}

# Iniciar monitoramento
start_monitoring() {
    if pgrep -f "security-monitor.sh" > /dev/null; then
        log "WARN" "Monitoramento j√° est√° ativo"
        return
    fi
    
    log "STEP" "Iniciando monitoramento em tempo real..."
    
    echo ""
    echo "Op√ß√µes de monitoramento:"
    echo "1) Cont√≠nuo (at√© ser parado manualmente)"
    echo "2) Por tempo limitado"
    echo ""
    
    read -p "Escolha [1]: " monitor_choice
    monitor_choice=${monitor_choice:-1}
    
    local duration_arg=""
    if [[ "$monitor_choice" == "2" ]]; then
        read -p "Dura√ß√£o (ex: 1h, 30m): " duration
        if [[ -n "$duration" ]]; then
            duration_arg="--duration $duration"
        fi
    fi
    
    # Iniciar em background
    nohup "$PROJECT_ROOT/scripts/security-monitor.sh" --environment "$ENVIRONMENT" $duration_arg > /dev/null 2>&1 &
    
    sleep 2
    
    if pgrep -f "security-monitor.sh" > /dev/null; then
        log "SUCCESS" "Monitoramento iniciado!"
        log "INFO" "Use a op√ß√£o 6 para parar o monitoramento"
    else
        log "ERROR" "Falha ao iniciar monitoramento"
    fi
    
    pause_for_user
}

# Parar monitoramento
stop_monitoring() {
    if ! pgrep -f "security-monitor.sh" > /dev/null; then
        log "WARN" "Monitoramento n√£o est√° ativo"
        return
    fi
    
    log "STEP" "Parando monitoramento..."
    
    pkill -f "security-monitor.sh" 2>/dev/null || true
    
    sleep 2
    
    if ! pgrep -f "security-monitor.sh" > /dev/null; then
        log "SUCCESS" "Monitoramento parado!"
    else
        log "ERROR" "Falha ao parar monitoramento"
    fi
    
    pause_for_user
}

# Verificar alertas
check_alerts() {
    log "STEP" "Verificando alertas recentes..."
    
    "$PROJECT_ROOT/scripts/security-monitor.sh" --check-alerts --environment "$ENVIRONMENT"
    
    pause_for_user
}

# Rotacionar secrets
rotate_secrets() {
    log "STEP" "Rota√ß√£o de secrets..."
    
    echo ""
    log "WARN" "Esta opera√ß√£o ir√° rotacionar credenciais sens√≠veis!"
    echo ""
    echo "Tipos de rota√ß√£o:"
    echo "1) Apenas banco de dados"
    echo "2) Apenas chaves de API"  
    echo "3) Todos os secrets (ATEN√á√ÉO: pode afetar servi√ßos)"
    echo ""
    
    read -p "Escolha [1]: " rotation_choice
    rotation_choice=${rotation_choice:-1}
    
    local rotation_type="rotate-db"
    case "$rotation_choice" in
        1) rotation_type="rotate-db" ;;
        2) rotation_type="rotate-api" ;;
        3) rotation_type="rotate-all" ;;
    esac
    
    echo ""
    read -p "Confirmar rota√ß√£o? [y/N]: " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        log "INFO" "Rota√ß√£o cancelada"
        return
    fi
    
    if "$PROJECT_ROOT/scripts/rotate-secrets.sh" --environment "$ENVIRONMENT" "$rotation_type"; then
        log "SUCCESS" "Rota√ß√£o conclu√≠da!"
    else
        log "ERROR" "Falha na rota√ß√£o"
    fi
    
    pause_for_user
}

# Criar backup
create_backup() {
    log "STEP" "Criando backup completo..."
    
    if "$PROJECT_ROOT/scripts/backup-recovery.sh" backup --environment "$ENVIRONMENT"; then
        log "SUCCESS" "Backup criado!"
        
        # Mostrar localiza√ß√£o
        local latest_backup=$(find "$PROJECT_ROOT/backups" -name "backup-*.tar.gz*" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2- || echo "")
        if [[ -n "$latest_backup" ]]; then
            log "INFO" "Backup salvo: $(basename "$latest_backup")"
        fi
    else
        log "ERROR" "Falha ao criar backup"
    fi
    
    pause_for_user
}

# Restaurar backup
restore_backup() {
    log "STEP" "Restaurar do backup..."
    
    # Listar backups dispon√≠veis
    echo ""
    log "INFO" "Backups dispon√≠veis:"
    "$PROJECT_ROOT/scripts/backup-recovery.sh" list
    
    echo ""
    read -p "Nome do arquivo de backup: " backup_file
    
    if [[ -n "$backup_file" ]]; then
        echo ""
        log "WARN" "Esta opera√ß√£o ir√° sobrescrever configura√ß√µes atuais!"
        read -p "Confirmar restore? [y/N]: " confirm
        
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            if "$PROJECT_ROOT/scripts/backup-recovery.sh" restore --file "$backup_file"; then
                log "SUCCESS" "Restore conclu√≠do!"
                log "INFO" "Reinicie os servi√ßos para aplicar as mudan√ßas"
            else
                log "ERROR" "Falha no restore"
            fi
        else
            log "INFO" "Restore cancelado"
        fi
    fi
    
    pause_for_user
}

# Abrir dashboard
open_dashboard() {
    log "STEP" "Abrindo dashboard de seguran√ßa..."
    
    if "$PROJECT_ROOT/scripts/security-dashboard.sh" --environment "$ENVIRONMENT" --open; then
        log "SUCCESS" "Dashboard aberto!"
        log "INFO" "Se n√£o abriu automaticamente, acesse: dashboard.html"
    else
        log "ERROR" "Falha ao gerar dashboard"
    fi
    
    pause_for_user
}

# Gerar relat√≥rio
generate_report() {
    log "STEP" "Gerando relat√≥rio de seguran√ßa..."
    
    echo ""
    echo "Formatos dispon√≠veis:"
    echo "1) HTML (recomendado)"
    echo "2) PDF"
    echo "3) JSON"
    echo ""
    
    read -p "Escolha [1]: " format_choice
    format_choice=${format_choice:-1}
    
    local format="html"
    case "$format_choice" in
        1) format="html" ;;
        2) format="pdf" ;;
        3) format="json" ;;
    esac
    
    if "$PROJECT_ROOT/scripts/security-audit.sh" --generate-report --format "$format" --environment "$ENVIRONMENT"; then
        log "SUCCESS" "Relat√≥rio gerado!"
        
        local latest_report=$(find "$PROJECT_ROOT/reports" -name "*.$format" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2- || echo "")
        if [[ -n "$latest_report" ]]; then
            log "INFO" "Relat√≥rio: $latest_report"
            
            if [[ "$format" == "html" ]] && command -v xdg-open &> /dev/null; then
                read -p "Abrir relat√≥rio no navegador? [y/N]: " open_report
                if [[ "$open_report" =~ ^[Yy]$ ]]; then
                    xdg-open "$latest_report" &>/dev/null &
                fi
            fi
        fi
    else
        log "ERROR" "Falha ao gerar relat√≥rio"
    fi
    
    pause_for_user
}

# Ver logs
view_logs() {
    log "STEP" "Visualizando logs recentes..."
    
    echo ""
    echo "Tipos de log:"
    echo "1) Monitoramento"
    echo "2) Scans"
    echo "3) Auditoria"
    echo "4) Rota√ß√£o de secrets"
    echo "5) Todos"
    echo ""
    
    read -p "Escolha [1]: " log_choice
    log_choice=${log_choice:-1}
    
    local log_pattern=""
    case "$log_choice" in
        1) log_pattern="security-monitor-*.log" ;;
        2) log_pattern="security-scan-*.log" ;;
        3) log_pattern="security-audit-*.log" ;;
        4) log_pattern="rotate-secrets-*.log" ;;
        5) log_pattern="*.log" ;;
    esac
    
    local latest_log=$(find "$PROJECT_ROOT/logs" -name "$log_pattern" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2- || echo "")
    
    if [[ -n "$latest_log" ]]; then
        echo ""
        log "INFO" "Mostrando: $(basename "$latest_log")"
        echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        tail -50 "$latest_log" | while IFS= read -r line; do
            # Colorir linhas baseado no conte√∫do
            if [[ "$line" =~ ERROR ]]; then
                echo -e "${RED}$line${NC}"
            elif [[ "$line" =~ WARN ]]; then
                echo -e "${YELLOW}$line${NC}"
            elif [[ "$line" =~ SUCCESS ]]; then
                echo -e "${GREEN}$line${NC}"
            else
                echo "$line"
            fi
        done
        echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    else
        log "WARN" "Nenhum log encontrado para o padr√£o: $log_pattern"
    fi
    
    pause_for_user
}

# Configurar sistema
configure_system() {
    log "STEP" "Configura√ß√£o do sistema..."
    
    echo ""
    echo "Op√ß√µes de configura√ß√£o:"
    echo "1) Reconfigurar ambiente completo"
    echo "2) Editar arquivo de configura√ß√£o"
    echo "3) Configurar notifica√ß√µes"
    echo "4) Configurar credenciais cloud"
    echo ""
    
    read -p "Escolha [1]: " config_choice
    config_choice=${config_choice:-1}
    
    case "$config_choice" in
        1)
            log "INFO" "Reconfigurando sistema..."
            "$PROJECT_ROOT/scripts/init-security.sh" --environment "$ENVIRONMENT" --force
            ;;
        2)
            local config_file="$PROJECT_ROOT/.env.security"
            if [[ -f "$config_file" ]]; then
                log "INFO" "Abrindo editor para: $config_file"
                "${EDITOR:-nano}" "$config_file"
            else
                log "ERROR" "Arquivo de configura√ß√£o n√£o encontrado"
            fi
            ;;
        3)
            configure_notifications
            ;;
        4)
            configure_cloud_credentials
            ;;
    esac
    
    pause_for_user
}

# Configurar notifica√ß√µes
configure_notifications() {
    log "INFO" "Configurando notifica√ß√µes..."
    
    local env_file="$PROJECT_ROOT/.env.security"
    
    echo ""
    read -p "Discord Webhook URL: " discord_webhook
    read -p "Slack Webhook URL: " slack_webhook
    read -p "Email SMTP Host: " smtp_host
    read -p "Email From: " email_from
    read -p "Email To: " email_to
    
    # Atualizar arquivo de configura√ß√£o
    if [[ -f "$env_file" ]]; then
        # Fazer backup
        cp "$env_file" "$env_file.backup"
        
        # Atualizar valores
        sed -i "s|DISCORD_WEBHOOK_URL=.*|DISCORD_WEBHOOK_URL=\"$discord_webhook\"|" "$env_file"
        sed -i "s|SLACK_WEBHOOK_URL=.*|SLACK_WEBHOOK_URL=\"$slack_webhook\"|" "$env_file"
        sed -i "s|EMAIL_SMTP_HOST=.*|EMAIL_SMTP_HOST=\"$smtp_host\"|" "$env_file"
        sed -i "s|EMAIL_FROM=.*|EMAIL_FROM=\"$email_from\"|" "$env_file"
        sed -i "s|EMAIL_TO=.*|EMAIL_TO=\"$email_to\"|" "$env_file"
        
        log "SUCCESS" "Notifica√ß√µes configuradas!"
    else
        log "ERROR" "Arquivo de configura√ß√£o n√£o encontrado"
    fi
}

# Configurar credenciais cloud
configure_cloud_credentials() {
    log "INFO" "Configurando credenciais cloud..."
    
    echo ""
    echo "Selecione o provedor cloud:"
    echo "1) Azure (para staging)"
    echo "2) AWS (para produ√ß√£o)"
    echo ""
    
    read -p "Escolha: " cloud_choice
    
    case "$cloud_choice" in
        1)
            echo ""
            log "INFO" "Configurando Azure..."
            echo "Execute: az login"
            echo "Depois configure as vari√°veis no .env.security:"
            echo "  AZURE_SUBSCRIPTION_ID"
            echo "  AZURE_TENANT_ID" 
            echo "  AZURE_CLIENT_ID"
            echo "  AZURE_CLIENT_SECRET"
            ;;
        2)
            echo ""
            log "INFO" "Configurando AWS..."
            echo "Execute: aws configure"
            echo "Depois configure as vari√°veis no .env.security:"
            echo "  AWS_ACCESS_KEY_ID"
            echo "  AWS_SECRET_ACCESS_KEY"
            echo "  AWS_REGION"
            ;;
    esac
}

# Limpeza e manuten√ß√£o
cleanup_maintenance() {
    log "STEP" "Executando limpeza e manuten√ß√£o..."
    
    echo ""
    echo "Op√ß√µes de limpeza:"
    echo "1) Logs antigos (>30 dias)"
    echo "2) Backups antigos (>30 dias)"  
    echo "3) Relat√≥rios antigos (>90 dias)"
    echo "4) Limpeza completa"
    echo ""
    
    read -p "Escolha [4]: " cleanup_choice
    cleanup_choice=${cleanup_choice:-4}
    
    case "$cleanup_choice" in
        1)
            find "$PROJECT_ROOT/logs" -name "*.log" -type f -mtime +30 -delete 2>/dev/null || true
            log "SUCCESS" "Logs antigos removidos"
            ;;
        2)
            "$PROJECT_ROOT/scripts/backup-recovery.sh" cleanup --retention 30
            ;;
        3)
            find "$PROJECT_ROOT/reports" -name "*.html" -o -name "*.pdf" -type f -mtime +90 -delete 2>/dev/null || true
            log "SUCCESS" "Relat√≥rios antigos removidos"
            ;;
        4)
            find "$PROJECT_ROOT/logs" -name "*.log" -type f -mtime +30 -delete 2>/dev/null || true
            "$PROJECT_ROOT/scripts/backup-recovery.sh" cleanup --retention 30 2>/dev/null || true
            find "$PROJECT_ROOT/reports" -name "*.html" -o -name "*.pdf" -type f -mtime +90 -delete 2>/dev/null || true
            find /tmp -name "*pro-mata*" -type f -mtime +1 -delete 2>/dev/null || true
            log "SUCCESS" "Limpeza completa executada"
            ;;
    esac
    
    pause_for_user
}

# Mostrar ajuda
show_help() {
    log "STEP" "Ajuda e documenta√ß√£o..."
    
    echo ""
    echo -e "${CYAN}üìö DOCUMENTA√á√ÉO DISPON√çVEL:${NC}"
    echo ""
    echo "‚Ä¢ README.md - Guia principal do projeto"
    echo "‚Ä¢ docs/security-migration-guide.md - Guia de migra√ß√£o"
    echo "‚Ä¢ security/security-config.yml - Configura√ß√µes principais"
    echo ""
    echo -e "${CYAN}üîß COMANDOS MAKEFILE:${NC}"
    echo ""
    echo "‚Ä¢ make security-init     - Inicializar sistema"
    echo "‚Ä¢ make security-check    - Verifica√ß√£o geral" 
    echo "‚Ä¢ make security-scan     - Scan de vulnerabilidades"
    echo "‚Ä¢ make security-audit    - Auditoria de conformidade"
    echo "‚Ä¢ make security-monitor  - Monitoramento em tempo real"
    echo "‚Ä¢ make security-rotate   - Rota√ß√£o de secrets"
    echo "‚Ä¢ make security-backup   - Backup completo"
    echo ""
    echo -e "${CYAN}üÜò SUPORTE:${NC}"
    echo ""
    echo "‚Ä¢ Discord: Canal #infra-pro-mata"
    echo "‚Ä¢ GitHub Issues: https://github.com/AGES-Pro-Mata/infra/issues"
    echo ""
    echo -e "${CYAN}üö® COMANDOS DE EMERG√äNCIA:${NC}"
    echo ""
    echo "‚Ä¢ make security-emergency-rotate  - Rota√ß√£o de emerg√™ncia"
    echo "‚Ä¢ make security-emergency-lockdown - Lockdown do sistema"
    echo ""
    
    pause_for_user
}

# Pausa para o usu√°rio ler
pause_for_user() {
    echo ""
    read -p "Pressione Enter para continuar..."
}

# Executar setup se necess√°rio
run_setup() {
    log "STEP" "Inicializando sistema de seguran√ßa..."
    
    if "$PROJECT_ROOT/scripts/init-security.sh" --environment "$ENVIRONMENT" --skip-deps; then
        log "SUCCESS" "Sistema inicializado com sucesso!"
    else
        log "ERROR" "Falha na inicializa√ß√£o"
        exit 1
    fi
}

# Loop principal
main_loop() {
    while true; do
        show_banner
        
        # Mostrar status
        echo -e "${PURPLE}Ambiente atual: $ENVIRONMENT${NC}"
        
        # Verificar status rapidamente
        if check_system_status; then
            echo -e "${GREEN}Status: Sistema OK${NC}"
        else
            echo -e "${YELLOW}Status: Issues encontrados${NC}"
        fi
        
        show_main_menu
        
        read -p "Escolha uma op√ß√£o: " choice
        
        case "$choice" in
            1) run_security_scan ;;
            2) run_security_audit ;;
            3) run_tests ;;
            4) check_system_status; pause_for_user ;;
            5) start_monitoring ;;
            6) stop_monitoring ;;
            7) check_alerts ;;
            8) rotate_secrets ;;
            9) create_backup ;;
            10) restore_backup ;;
            11) open_dashboard ;;
            12) generate_report ;;
            13) view_logs ;;
            14) configure_system ;;
            15) cleanup_maintenance ;;
            16) show_help ;;
            0) 
                log "INFO" "Finalizando Pro-Mata Security System..."
                echo -e "${CYAN}Obrigado por usar o Pro-Mata Security! üîê${NC}"
                exit 0
                ;;
            *)
                log "ERROR" "Op√ß√£o inv√°lida: $choice"
                sleep 2
                ;;
        esac
    done
}

# Parse de argumentos
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --environment|-e)
                ENVIRONMENT="$2"
                shift 2
                ;;
            --non-interactive)
                INTERACTIVE=false
                shift
                ;;
            --setup)
                SETUP_MODE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                log "ERROR" "Argumento desconhecido: $1"
                exit 1
                ;;
        esac
    done
}

# Fun√ß√£o principal
main() {
    parse_arguments "$@"
    
    if [[ "$INTERACTIVE" == "false" ]]; then
        # Modo n√£o interativo - apenas verificar status
        detect_environment
        if check_initialization || [[ "$SETUP_MODE" == "true" ]]; then
            check_system_status
        else
            run_setup
        fi
        return
    fi
    
    # Modo interativo
    detect_environment
    
    if ! check_initialization || [[ "$SETUP_MODE" == "true" ]]; then
        show_banner
        run_setup
        echo ""
        read -p "Pressione Enter para continuar para o menu principal..."
    fi
    
    main_loop
}

# Executar se chamado diretamente
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi