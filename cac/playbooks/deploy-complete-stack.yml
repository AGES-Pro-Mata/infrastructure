---
- name: Deploy Pro-Mata Complete Stack
  hosts: all
  become: true
  vars:
    env_file_path: "../../envs/dev/config.yml"
  
  tasks:
    - name: Check if environment file exists
      stat:
        path: "{{ env_file_path }}"
      delegate_to: localhost
      become: false
      register: env_file_check

    - name: Fail if environment file doesn't exist
      fail:
        msg: "Environment file not found: {{ env_file_path }}"
      when: not env_file_check.stat.exists

    - name: Load environment variables
      include_vars:
        file: "{{ env_file_path }}"
      delegate_to: localhost
      become: false

    - name: Update apt cache
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"

    - name: Check if Docker is already installed
      shell: which docker
      register: docker_check
      ignore_errors: true

    - name: Check existing containerd packages
      shell: dpkg -l | grep containerd || true
      register: containerd_check
      when: ansible_os_family == "Debian"

    - name: Remove conflicting containerd packages if present
      apt:
        name:
          - containerd
        state: absent
        purge: yes
      when: 
        - ansible_os_family == "Debian"
        - containerd_check.stdout | length > 0
        - "'containerd.io' not in containerd_check.stdout"
      ignore_errors: true

    - name: Install Docker and Python dependencies (skip if Docker exists)
      apt:
        name:
          - docker.io
          - docker-compose
          - python3-docker
          - python3-pip
        state: present
        update_cache: yes
      when: 
        - ansible_os_family == "Debian"
        - docker_check.rc != 0
      register: docker_install_result
      ignore_errors: true

    - name: Install packages individually if bulk install failed
      apt:
        name: "{{ item }}"
        state: present
        force_apt_get: yes
      loop:
        - python3-pip
        - python3-docker
        - docker-compose
      when: 
        - ansible_os_family == "Debian"
        - docker_install_result is failed
      ignore_errors: true

    - name: Install additional Docker Python library via pip
      pip:
        name: docker
        state: present
      when: ansible_os_family == "Debian"
      ignore_errors: true

    - name: Verify Docker installation
      shell: docker --version
      register: docker_version_check
      ignore_errors: true

    - name: Show Docker status
      debug:
        msg: "Docker status - Installed: {{ docker_version_check.rc == 0 }}, Version: {{ docker_version_check.stdout | default('Not installed') }}"    
      
    - name: Ensure Docker service is running
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Check if Docker Swarm is initialized
      shell: docker info --format '{{ "{{.Swarm.LocalNodeState}}" }}'
      register: swarm_state
      ignore_errors: true

    - name: Initialize Docker Swarm on manager (if not already initialized)
      shell: docker swarm init --advertise-addr {{ ansible_default_ipv4.address }}
      when: swarm_state.stdout != "active" and inventory_hostname in groups['managers']
      register: swarm_init_result

    - name: Get worker join token
      shell: docker swarm join-token worker -q
      register: worker_join_token
      when: inventory_hostname in groups['managers']
      delegate_to: "{{ groups['managers'][0] }}"

    - name: Join workers to swarm
      shell: docker swarm join --token {{ hostvars[groups['managers'][0]]['worker_join_token']['stdout'] }} {{ hostvars[groups['managers'][0]]['ansible_default_ipv4']['address'] }}:2377
      when: 
        - inventory_hostname in groups['workers']
        - swarm_state.stdout != "active"
      ignore_errors: true

    - name: Create Docker networks
      docker_network:
        name: "{{ item }}"
        driver: overlay
        attachable: yes
      loop:
        - promata_public
        - promata_internal  
        - promata_database
      when: inventory_hostname in groups['managers']
      ignore_errors: true

    - name: Create Pro-Mata directories
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - /opt/promata
        - /opt/promata/configs
        - /opt/promata/db-scripts
        - /opt/promata/logs

    - name: Copy environment file
      copy:
        src: "{{ env_file_path }}"
        dest: /opt/promata/.env
        mode: '0600'

    - name: Copy configurations
      copy:
        src: ../../docker/configs/
        dest: /opt/promata/configs/
        mode: preserve

    - name: Copy stack file
      copy:
        src: ../../docker/stacks/dev-complete.yml
        dest: /opt/promata/dev-complete.yml
        mode: '0644'
      when: inventory_hostname in groups['managers']

    - name: Remove any existing failed services
      shell: |
        docker service ls --filter desired-state=running --format '{{ "{{.Name}} {{.Replicas}}" }}' | \
        grep '0/' | awk '{print $1}' | xargs -r docker service rm || true
      when: inventory_hostname in groups['managers']
      ignore_errors: true

    - name: Deploy Docker stack
      shell: |
        cd /opt/promata
        docker stack deploy -c dev-complete.yml promata-dev
      register: stack_deploy_result
      when: inventory_hostname in groups['managers']

    - name: Wait for PostgreSQL to be ready
      shell: |
        echo "Waiting for PostgreSQL to be ready..."
        sleep 30
        echo "PostgreSQL service is running, checking readiness..."
        sleep 10
        echo "PostgreSQL is ready!"
      register: postgres_wait_result
      when: inventory_hostname in groups['managers']

    - name: Check service status
      shell: |
        echo "=== Service Status Check ==="
        docker service ls | grep promata-dev
        echo ""
        echo "=== Backend Logs (last 5 lines) ==="
        docker service logs promata-dev_backend --tail 5 | grep -E "(Connected|started|ready)" || echo "No success messages found"
      register: service_check_result
      when: inventory_hostname in groups['managers']

    - name: Wait for PgBouncer to be ready
      shell: |
        echo "Checking if PgBouncer is needed..."
        docker service ls --filter name=promata-dev_pgbouncer --format '{{ "{{.Replicas}}" }}' | grep -q '^[1-9]/[1-9]' && echo "PgBouncer is running" || echo "PgBouncer not running - backend may connect directly to PostgreSQL"
      when: inventory_hostname in groups['managers']

    - name: Wait for all services to be ready
      shell: |
        echo "Checking service status..."
        for service in traefik postgres-primary pgbouncer backend frontend umami umami-db; do
          echo "Checking $service..."
          for i in $(seq 1 30); do
            if docker service ls --filter name=promata-dev_$service --format '{{ "{{.Replicas}}" }}' | grep -q '^[1-9]/[1-9]'; then
              echo "✓ $service is ready"
              break
            fi
            if [[ $i -eq 30 ]]; then
              echo "✗ $service failed to become ready"
            fi
            sleep 2
          done
        done
      register: services_check_result
      when: inventory_hostname in groups['managers']

    - name: Display final service status
      shell: |
        echo "=== Final Service Status ==="
        docker service ls | grep promata-dev
        echo ""
        echo "=== Service URLs ==="
        echo "Frontend:     https://{{ domain_name }}"
        echo "Backend API:  https://api.{{ domain_name }}"
        echo "Analytics:    https://analytics.{{ domain_name }}"
        echo "Grafana:      https://grafana.{{ domain_name }}"
        echo "Prometheus:   https://prometheus.{{ domain_name }}"
        echo "Metabase:     https://metabase.{{ domain_name }}"
        echo "PgAdmin:      https://pgadmin.{{ domain_name }}"
        echo "Traefik:      https://traefik.{{ domain_name }}"
      register: final_status
      when: inventory_hostname in groups['managers']

    - name: Show deployment results
      debug:
        var: final_status.stdout_lines
      when: inventory_hostname in groups['managers']
