---
- name: Deploy Pro-Mata Complete Stack
  hosts: all
  become: true
  vars_files:
    - ../inventory/dev/group_vars/all.yml
  
  tasks:

    - name: Update apt cache
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"

    - name: Check if Docker is already installed
      shell: which docker
      register: docker_check
      ignore_errors: true

    - name: Check existing containerd packages
      shell: dpkg -l | grep containerd || true
      register: containerd_check
      when: ansible_os_family == "Debian"

    - name: Remove conflicting containerd packages if present
      apt:
        name:
          - containerd
        state: absent
        purge: yes
      when: 
        - ansible_os_family == "Debian"
        - containerd_check.stdout | length > 0
        - "'containerd.io' not in containerd_check.stdout"
      ignore_errors: true

    - name: Install Docker and Python dependencies (skip if Docker exists)
      apt:
        name:
          - docker.io
          - docker-compose
          - python3-docker
          - python3-pip
        state: present
        update_cache: yes
      when: 
        - ansible_os_family == "Debian"
        - docker_check.rc != 0
      register: docker_install_result
      ignore_errors: true

    - name: Install packages individually if bulk install failed
      apt:
        name: "{{ item }}"
        state: present
        force_apt_get: yes
      loop:
        - python3-pip
        - python3-docker
        - docker-compose
      when: 
        - ansible_os_family == "Debian"
        - docker_install_result is failed
      ignore_errors: true

    - name: Install additional Docker Python library via pip
      pip:
        name: docker
        state: present
      when: ansible_os_family == "Debian"
      ignore_errors: true

    - name: Verify Docker installation
      shell: docker --version
      register: docker_version_check
      ignore_errors: true

    - name: Show Docker status
      debug:
        msg: "Docker status - Installed: {{ docker_version_check.rc == 0 }}, Version: {{ docker_version_check.stdout | default('Not installed') }}"    
      
    - name: Ensure Docker service is running
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Check if Docker Swarm is initialized
      shell: docker info --format '{{ "{{.Swarm.LocalNodeState}}" }}'
      register: swarm_state
      ignore_errors: true

    - name: Initialize Docker Swarm on manager (if not already initialized)
      shell: docker swarm init --advertise-addr {{ ansible_default_ipv4.address }}
      when: swarm_state.stdout != "active" and inventory_hostname in groups['managers']
      register: swarm_init_result

    - name: Get worker join token
      shell: docker swarm join-token worker -q
      register: worker_join_token
      when: inventory_hostname in groups['managers']
      delegate_to: "{{ groups['managers'][0] }}"

    - name: Join workers to swarm
      shell: docker swarm join --token {{ hostvars[groups['managers'][0]]['worker_join_token']['stdout'] }} {{ hostvars[groups['managers'][0]]['ansible_default_ipv4']['address'] }}:2377
      when: 
        - inventory_hostname in groups['workers']
        - swarm_state.stdout != "active"
      ignore_errors: true

    - name: Create Docker networks
      docker_network:
        name: "{{ item }}"
        driver: overlay
        attachable: yes
      loop:
        - promata_public
        - promata_internal  
        - promata_database
      when: inventory_hostname in groups['managers']
      ignore_errors: true

    - name: Create Pro-Mata directories
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - /opt/promata
        - /opt/promata/configs
        - /opt/promata/db-scripts
        - /opt/promata/logs

    - name: Generate/Update .env file with all required variables from vault
      copy:
        content: |
          # Pro-Mata Development Environment Configuration
          # Auto-generated by Ansible - {{ ansible_date_time.iso8601 }}
          # Using vault variables for secure authentication
          
          # Environment Settings
          export environment="{{ environment }}"
          export project_name="{{ project_name }}"
          export env_color="{{ stack_environment.env_color }}"
          
          # Domain Configuration
          export domain_name="{{ domain_name }}"
          export DOMAIN_NAME="{{ domain_name }}"
          export ACME_EMAIL="{{ stack_environment.ACME_EMAIL }}"
          
          # Infrastructure
          export MANAGER_IP="{{ stack_environment.MANAGER_IP }}"
          
          # Database Configuration - Using vault variables
          export POSTGRES_DB="{{ stack_environment.POSTGRES_DB }}"
          export POSTGRES_USER="{{ stack_environment.POSTGRES_USER }}"
          export POSTGRES_PASSWORD="{{ VAULT_POSTGRES_PASSWORD | default(stack_environment.POSTGRES_PASSWORD) }}"
          
          # Prisma Configuration - Using vault variables
          export DATABASE_URL="postgresql://{{ stack_environment.POSTGRES_USER }}:{{ VAULT_POSTGRES_PASSWORD | default(stack_environment.POSTGRES_PASSWORD) }}@postgres:5432/{{ stack_environment.POSTGRES_DB }}?schema=public"
          export PRISMA_DATABASE_URL="postgresql://{{ stack_environment.POSTGRES_USER }}:{{ VAULT_POSTGRES_PASSWORD | default(stack_environment.POSTGRES_PASSWORD) }}@postgres:5432/{{ stack_environment.POSTGRES_DB }}?schema=public"
          export PRISMA_USER="{{ stack_environment.PRISMA_USER }}"
          export PRISMA_PASSWORD="{{ VAULT_PRISMA_PASSWORD | default(stack_environment.PRISMA_PASSWORD) }}"
          
          # Application Security - Using vault variables
          export JWT_SECRET="{{ VAULT_JWT_SECRET | default(stack_environment.JWT_SECRET) }}"
          export JWT_EXPIRES_IN="{{ stack_environment.JWT_EXPIRES_IN }}"
          
          # Traefik Configuration - Using vault variables
          export TRAEFIK_LOG_LEVEL="{{ stack_environment.TRAEFIK_LOG_LEVEL }}"
          export TRAEFIK_AUTH_USERS="{{ VAULT_TRAEFIK_AUTH_USERS | default(stack_environment.TRAEFIK_AUTH_USERS) }}"
          
          # Cloudflare Configuration - Using vault variables
          export CLOUDFLARE_API_TOKEN="{{ VAULT_CLOUDFLARE_API_TOKEN | default(stack_environment.CLOUDFLARE_API_TOKEN) }}"
          export CLOUDFLARE_ZONE_ID="{{ VAULT_CLOUDFLARE_ZONE_ID | default(stack_environment.CLOUDFLARE_ZONE_ID) }}"
          
          # Application Images
          export BACKEND_IMAGE="{{ stack_environment.BACKEND_IMAGE }}"
          export DATABASE_IMAGE="{{ stack_environment.DATABASE_IMAGE }}"
          
          # Monitoring & Tools - Using vault variables
          
          # PgBouncer Configuration
          export PGBOUNCER_POOL_MODE="{{ stack_environment.PGBOUNCER_POOL_MODE }}"
          export PGBOUNCER_POOL_SIZE="{{ stack_environment.PGBOUNCER_POOL_SIZE }}"
          export PGBOUNCER_MAX_CLIENT_CONN="{{ stack_environment.PGBOUNCER_MAX_CLIENT_CONN }}"
          export PGBOUNCER_AUTH_TYPE="{{ stack_environment.PGBOUNCER_AUTH_TYPE }}"
          
          # Analytics - Umami - Using vault variables
          export UMAMI_DB_PASSWORD="{{ VAULT_UMAMI_DB_PASSWORD | default(stack_environment.UMAMI_DB_PASSWORD) }}"
          export UMAMI_WEBSITE_ID="{{ VAULT_UMAMI_WEBSITE_ID | default(stack_environment.UMAMI_WEBSITE_ID) }}"
          export UMAMI_HASH_SALT="{{ VAULT_UMAMI_HASH_SALT | default(stack_environment.UMAMI_HASH_SALT) }}"
          export UMAMI_SECRET="{{ VAULT_UMAMI_SECRET | default(stack_environment.UMAMI_SECRET) }}"
          
          # Metabase Configuration - Using vault variables
          export METABASE_DB_PASSWORD="{{ VAULT_METABASE_DB_PASSWORD | default(stack_environment.METABASE_DB_PASSWORD) }}"
          export MB_ENCRYPTION_SECRET_KEY="{{ VAULT_MB_ENCRYPTION_SECRET_KEY | default(stack_environment.MB_ENCRYPTION_SECRET_KEY) }}"
          
          # Backup Configuration - Using vault variables
          export BACKUP_ENCRYPTION_KEY="{{ VAULT_BACKUP_ENCRYPTION_KEY | default(stack_environment.BACKUP_ENCRYPTION_KEY) }}"
        dest: /opt/promata/.env
        mode: '0600'
        backup: yes

    - name: Verify environment variables are loaded correctly
      shell: |
        cd /opt/promata
        source .env
        echo "✓ Domain: $domain_name"
        echo "✓ Database User: $POSTGRES_USER"
        echo "✓ Backend Image: $BACKEND_IMAGE"
        echo "✓ Environment variables loaded successfully"
      register: env_verification

    - name: Show environment verification
      debug:
        var: env_verification.stdout_lines

    - name: Copy configurations
      copy:
        src: ../../docker/configs/
        dest: /opt/promata/configs/
        mode: preserve

    - name: Copy stack file with interpolated variables
      template:
        src: ../../docker/stacks/dev-complete.yml
        dest: /opt/promata/dev-complete.yml
        mode: '0644'
      when: inventory_hostname in groups['managers']

    - name: Remove any existing failed services
      shell: |
        docker service ls --filter desired-state=running --format '{{ "{{.Name}} {{.Replicas}}" }}' | \
        grep '0/' | awk '{print $1}' | xargs -r docker service rm || true
      when: inventory_hostname in groups['managers']
      ignore_errors: true

    - name: Deploy Docker stack with updated environment
      shell: |
        cd /opt/promata
        source .env
        echo "Deploying stack with updated environment variables..."
        docker stack deploy -c dev-complete.yml --with-registry-auth --prune promata-dev
      register: stack_deploy_result
      when: inventory_hostname in groups['managers']

    - name: Wait for PostgreSQL to be ready
      shell: |
        echo "Waiting for PostgreSQL to be ready..."
        sleep 30
        echo "PostgreSQL service is running, checking readiness..."
        sleep 10
        echo "PostgreSQL is ready!"
      register: postgres_wait_result
      when: inventory_hostname in groups['managers']

    - name: Check service status
      shell: |
        echo "=== Service Status Check ==="
        docker service ls | grep promata-dev
        echo ""
        echo "=== Backend Logs (last 5 lines) ==="
        docker service logs promata-dev_backend --tail 5 | grep -E "(Connected|started|ready)" || echo "No success messages found"
      register: service_check_result
      when: inventory_hostname in groups['managers']

    - name: Wait for PgBouncer to be ready
      shell: |
        echo "Checking if PgBouncer is needed..."
        docker service ls --filter name=promata-dev_pgbouncer --format '{{ "{{.Replicas}}" }}' | grep -q '^[1-9]/[1-9]' && echo "PgBouncer is running" || echo "PgBouncer not running - backend may connect directly to PostgreSQL"
      when: inventory_hostname in groups['managers']

    - name: Wait for all services to be ready
      shell: |
        echo "Checking service status..."
        for service in traefik postgres-primary pgbouncer backend umami umami-db; do
          echo "Checking $service..."
          for i in $(seq 1 30); do
            if docker service ls --filter name=promata-dev_$service --format '{{ "{{.Replicas}}" }}' | grep -q '^[1-9]/[1-9]'; then
              echo "✓ $service is ready"
              break
            fi
            if [[ $i -eq 30 ]]; then
              echo "✗ $service failed to become ready"
            fi
            sleep 2
          done
        done
      register: services_check_result
      when: inventory_hostname in groups['managers']

    - name: Display final service status
      shell: |
        echo "=== Final Service Status ==="
        docker service ls | grep promata-dev
        echo ""
        echo "=== Service URLs ==="
        echo "Backend API:  https://api.{{ domain_name }}"
        echo "Analytics:    https://analytics.{{ domain_name }}"
        echo "Metabase:     https://metabase.{{ domain_name }}"
        echo "Prisma-studio: https://prisma.{{ domain_name }}"
        echo "Traefik:      https://traefik.{{ domain_name }}"
      register: final_status
      when: inventory_hostname in groups['managers']

    - name: Show deployment results
      debug:
        var: final_status.stdout_lines
      when: inventory_hostname in groups['managers']
